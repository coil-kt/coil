{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Overview","text":"<p>An image loading library for Android and Compose Multiplatform. Coil is:</p> <ul> <li>Fast: Coil performs a number of optimizations including memory and disk caching, downsampling the image, automatically pausing/cancelling requests, and more.</li> <li>Lightweight: Coil only depends on Kotlin, Coroutines, and Okio and works seamlessly with Google's R8 code shrinker.</li> <li>Easy to use: Coil's API leverages Kotlin's language features for simplicity and minimal boilerplate.</li> <li>Modern: Coil is Kotlin-first and interoperates with modern libraries including Compose, Coroutines, Okio, OkHttp, and Ktor.</li> </ul> <p>Coil is an acronym for: Coroutine Image Loader.</p> <p>Translations: \u65e5\u672c\u8a9e, \ud55c\uad6d\uc5b4, \u0420\u0443\u0441\u0441\u043a\u0438\u0439, Svenska, T\u00fcrk\u00e7e, \u4e2d\u6587, \u067e\u0627\u0631\u0633\u06cc, O'zbekcha</p>"},{"location":"#quick-start","title":"Quick Start","text":"<p>Import the Compose library and a networking library:</p> <pre><code>implementation(\"io.coil-kt.coil3:coil-compose:3.4.0\")\nimplementation(\"io.coil-kt.coil3:coil-network-okhttp:3.4.0\")\n</code></pre> <p>To load an image, use the <code>AsyncImage</code> composable:</p> <pre><code>AsyncImage(\n    model = \"https://example.com/image.jpg\",\n    contentDescription = null,\n)\n</code></pre>"},{"location":"#license","title":"License","text":"<pre><code>Copyright 2025 Coil Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   https://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n</code></pre>"},{"location":"README-fa/","title":"README fa","text":"<p>\u06cc\u06a9 \u06a9\u062a\u0627\u0628\u062e\u0627\u0646\u0647\u200c\u06cc \u0628\u0627\u0631\u06af\u06cc\u0631\u06cc \u062a\u0635\u0627\u0648\u06cc\u0631 \u0628\u0631\u0627\u06cc Android \u0648 Compose Multiplatform. \u06a9\u0648\u06cc\u0644 \u0647\u0633\u062a:</p> <ul> <li>\u0633\u0631\u06cc\u0639: \u06a9\u0648\u06cc\u0644\u060c \u062a\u0639\u062f\u0627\u062f\u06cc \u0628\u0647\u06cc\u0646\u0647\u200c\u0633\u0627\u0632\u06cc \u0627\u0632 \u062c\u0645\u0644\u0647 \u0630\u062e\u06cc\u0631\u0647\u200c\u0633\u0627\u0632\u06cc (\u06a9\u0634\u200c\u06a9\u0631\u062f\u0646) \u062d\u0627\u0641\u0638\u0647\u060c \u0646\u0645\u0648\u0646\u0647\u200c\u0628\u0631\u062f\u0627\u0631\u06cc [\u06a9\u0627\u0647\u0634\u06cc] \u0627\u0632 \u062a\u0635\u0648\u06cc\u0631\u060c \u0645\u06a9\u062b \u0648 \u06cc\u0627 \u0644\u063a\u0648 \u062e\u0648\u062f\u06a9\u0627\u0631 \u062f\u0631\u062e\u0648\u0627\u0633\u062a\u200c\u0647\u0627 \u0648 \u063a\u06cc\u0631\u0647 \u0627\u0646\u062c\u0627\u0645 \u0645\u06cc\u200c\u0647\u062f.</li> <li>\u0633\u0628\u06a9: \u06a9\u0648\u06cc\u0644 \u0641\u0642\u0637 \u0628\u0647 \u06a9\u0627\u062a\u0644\u06cc\u0646\u060c Coroutine\u0647\u0627 \u0648 Okio \u0648\u0627\u0628\u0633\u062a\u0647 \u0627\u0633\u062a \u0648 \u0628\u0647\u200c\u0637\u0648\u0631 \u06cc\u06a9\u067e\u0627\u0631\u0686\u0647 \u0628\u0627 R8 code shrinker \u0627\u0632 \u06af\u0648\u06af\u0644 \u06a9\u0627\u0631 \u0645\u06cc\u200c\u06a9\u0646\u062f.</li> <li>\u0622\u0633\u0627\u0646 \u0628\u0631\u0627\u06cc \u0627\u0633\u062a\u0641\u0627\u062f\u0647: \u0648\u0627\u0633\u0637 \u0628\u0631\u0646\u0627\u0645\u0647\u200c\u0646\u0648\u06cc\u0633\u06cc (API) \u06a9\u0648\u06cc\u0644\u060c \u0627\u0632 \u0648\u06cc\u0698\u06af\u06cc\u200c\u0647\u0627\u06cc \u0632\u0628\u0627\u0646 Kotlin \u0628\u0631\u0627\u06cc \u0633\u0627\u062f\u06af\u06cc \u0648 \u062c\u0644\u0648\u06af\u06cc\u0631\u06cc \u0627\u0632 \u06a9\u062f\u0647\u0627\u06cc \u062a\u06a9\u0631\u0627\u0631\u06cc \u0628\u0647\u0631\u0647 \u0645\u06cc\u200c\u0628\u0631\u062f.</li> <li>\u0646\u0648\u06cc\u0646: \u06a9\u0648\u06cc\u0644 \u0645\u0628\u062a\u0646\u06cc \u0628\u0631 Kotlin \u0627\u0633\u062a \u0648 \u0628\u0627 \u06a9\u062a\u0627\u0628\u062e\u0627\u0646\u0647\u200c\u0647\u0627\u06cc \u062c\u062f\u06cc\u062f \u0627\u0632 \u062c\u0645\u0644\u0647 Compose\u060c \u06a9\u0648\u0631\u0648\u062a\u06cc\u0646\u200c\u0647\u0627\u060c \u0627\u0648\u06a9\u06cc\u0648\u060c OkHttp \u0648 Ktor \u06a9\u0627\u0631 \u0645\u06cc\u200c\u06a9\u0646\u062f.</li> </ul> <p>\u06a9\u0648\u06cc\u0644 (Coil) \u0645\u062e\u0641\u0641 \u0639\u0628\u0627\u0631\u062a \u0650 Coroutine Image Loader \u0627\u0633\u062a.</p>"},{"location":"README-fa/#_1","title":"\u0634\u0631\u0648\u0639 \u0641\u0648\u0631\u06cc","text":"<p>\u06a9\u062a\u0627\u0628\u062e\u0627\u0646\u0647\u200c\u06cc Compose \u0648 \u06cc\u06a9 networking library \u0631\u0627 \u0648\u0627\u0631\u062f (Import) \u06a9\u0646\u06cc\u062f:</p> <pre><code>implementation(\"io.coil-kt.coil3:coil-compose:3.4.0\")\nimplementation(\"io.coil-kt.coil3:coil-network-okhttp:3.4.0\")\n</code></pre> <p>\u0628\u0631\u0627\u06cc \u0628\u0627\u0631\u06af\u06cc\u0631\u06cc \u06cc\u06a9 \u062a\u0635\u0648\u06cc\u0631\u060c <code>AsyncImage</code> composable \u0631\u0627 \u0627\u0633\u062a\u0641\u0627\u062f\u0647 \u06a9\u0646\u06cc\u062f: <pre><code>AsyncImage(\n    model = \"https://example.com/image.jpg\",\n    contentDescription = null,\n)\n</code></pre></p> <p>\u0645\u0633\u062a\u0646\u062f\u0627\u062a \u06a9\u0627\u0645\u0644 Coil \u0631\u0627 \u0627\u0632 \u0627\u06cc\u0646\u062c\u0627 \u0628\u062e\u0648\u0627\u0646\u06cc\u062f.</p>"},{"location":"README-fa/#_2","title":"\u067e\u0631\u0648\u0627\u0646\u0647","text":"<pre><code>Copyright 2025 Coil Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   https://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n</code></pre>"},{"location":"README-ja/","title":"README ja","text":"<p>Android \u304a\u3088\u3073 Compose Multiplatform \u7528\u306e\u753b\u50cf\u8aad\u307f\u8fbc\u307f\u30e9\u30a4\u30d6\u30e9\u30ea\u3002Coil \u306e\u7279\u5fb4:</p> <ul> <li>\u9ad8\u901f: Coil \u306f\u3001\u30e1\u30e2\u30ea\u3068\u30c7\u30a3\u30b9\u30af\u306e\u30ad\u30e3\u30c3\u30b7\u30e5\u3001\u753b\u50cf\u306e\u30c0\u30a6\u30f3\u30b5\u30f3\u30d7\u30ea\u30f3\u30b0\u3001\u30ea\u30af\u30a8\u30b9\u30c8\u306e\u81ea\u52d5\u4e00\u6642\u505c\u6b62/\u30ad\u30e3\u30f3\u30bb\u30eb\u306a\u3069\u3001\u3055\u307e\u3056\u307e\u306a\u6700\u9069\u5316\u3092\u5b9f\u884c\u3057\u307e\u3059\u3002</li> <li>\u8efd\u91cf: Coil \u306f Kotlin\u3001Coroutines\u3001Okio \u306e\u307f\u306b\u4f9d\u5b58\u3057\u3001Google \u306e R8 \u30b3\u30fc\u30c9 \u30b7\u30e5\u30ea\u30f3\u30ab\u30fc\u3068\u30b7\u30fc\u30e0\u30ec\u30b9\u306b\u9023\u643a\u3057\u307e\u3059\u3002</li> <li>\u4f7f\u3044\u3084\u3059\u3044: Coil \u306e API \u306f\u3001\u30b7\u30f3\u30d7\u30eb\u3055\u3068\u6700\u5c0f\u9650\u306e\u5b9a\u578b\u6587\u3092\u5b9f\u73fe\u3059\u308b\u305f\u3081\u306b Kotlin \u306e\u8a00\u8a9e\u6a5f\u80fd\u3092\u6d3b\u7528\u3057\u3066\u3044\u307e\u3059\u3002</li> <li>\u6700\u65b0: Coil \u306f Kotlin \u30d5\u30a1\u30fc\u30b9\u30c8\u3067\u3042\u308a\u3001Compose\u3001Coroutines\u3001Okio\u3001OkHttp\u3001Ktor \u306a\u3069\u306e\u6700\u65b0\u306e\u30e9\u30a4\u30d6\u30e9\u30ea\u3068\u76f8\u4e92\u904b\u7528\u3067\u304d\u307e\u3059\u3002</li> </ul> <p>Coil \u306f\u3001Coroutine Image Loader \u306e\u982d\u5b57\u8a9e\u3067\u3059\u3002</p>"},{"location":"README-ja/#_1","title":"\u30af\u30a4\u30c3\u30af\u30b9\u30bf\u30fc\u30c8","text":"<p>Compose \u30e9\u30a4\u30d6\u30e9\u30ea\u3068 \u30cd\u30c3\u30c8\u30ef\u30fc\u30af \u30e9\u30a4\u30d6\u30e9\u30ea \u3092\u30a4\u30f3\u30dd\u30fc\u30c8\u3057\u307e\u3059:</p> <pre><code>implementation(\"io.coil-kt.coil3:coil-compose:3.4.0\")\nimplementation(\"io.coil-kt.coil3:coil-network-okhttp:3.4.0\")\n</code></pre> <p>\u753b\u50cf\u3092\u8aad\u307f\u8fbc\u3080\u306b\u306f\u3001<code>AsyncImage</code> \u3092\u4f7f\u7528\u3057\u307e\u3059composable:</p> <pre><code>AsyncImage(\n    model = \"https://example.com/image.jpg\",\n    contentDescription = null,\n)\n</code></pre> <p>Coil \u306e \u5b8c\u5168\u306a\u30c9\u30ad\u30e5\u30e1\u30f3\u30c8\u306f\u3053\u3061\u3089 \u3092\u3054\u89a7\u304f\u3060\u3055\u3044\u3002</p>"},{"location":"README-ja/#_2","title":"\u30e9\u30a4\u30bb\u30f3\u30b9","text":"<pre><code>Copyright 2025 Coil Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   https://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n</code></pre>"},{"location":"README-ko/","title":"README ko","text":"<p>Android \ubc0f Compose Multiplatform\uc744 \uc704\ud55c \uc774\ubbf8\uc9c0 \ub85c\ub529 \ub77c\uc774\ube0c\ub7ec\ub9ac\uc785\ub2c8\ub2e4. Coil\uc758 \ud2b9\uc9d5\uc740 \ub2e4\uc74c\uacfc \uac19\uc2b5\ub2c8\ub2e4.</p> <ul> <li>\ube60\ub984: Coil\uc740 \uba54\ubaa8\ub9ac \ubc0f \ub514\uc2a4\ud06c \uce90\uc2f1, \uc774\ubbf8\uc9c0 \ub2e4\uc6b4\uc0d8\ud50c\ub9c1, \uc694\uccad \uc790\ub3d9 \uc77c\uc2dc \uc911\uc9c0/\ucde8\uc18c \ub4f1 \uc5ec\ub7ec \uac00\uc9c0 \ucd5c\uc801\ud654\ub97c \uc218\ud589\ud569\ub2c8\ub2e4.</li> <li>\uac00\ubcbc\uc6c0: Coil\uc740 Kotlin, Coroutines, Okio\uc5d0\ub9cc \uc758\uc874\ud558\uba70 Google\uc758 R8 \ucf54\ub4dc \ucd95\uc18c\uae30\uc640 \uc6d0\ud65c\ud558\uac8c \uc791\ub3d9\ud569\ub2c8\ub2e4.</li> <li>\uc0ac\uc6a9\ud558\uae30 \uc26c\uc6c0: Coil\uc758 API\ub294 Kotlin\uc758 \uc5b8\uc5b4 \uae30\ub2a5\uc744 \ud65c\uc6a9\ud558\uc5ec \ub2e8\uc21c\uc131\uacfc \ucd5c\uc18c\ud55c\uc758 \ubcf4\uc77c\ub7ec\ud50c\ub808\uc774\ud2b8\ub97c \uc81c\uacf5\ud569\ub2c8\ub2e4.</li> <li>\ud604\ub300\uc801: Coil\uc740 Kotlin\uc744 \uc6b0\uc120\uc73c\ub85c \ud558\uba70 Compose, Coroutines, Okio, OkHttp, Ktor\ub97c \ud3ec\ud568\ud55c \ucd5c\uc2e0 \ub77c\uc774\ube0c\ub7ec\ub9ac\uc640 \uc0c1\ud638 \uc6b4\uc6a9\ub429\ub2c8\ub2e4.</li> </ul> <p>\ucf54\uc77c\uc740 Coroutine Image Loader\uc758 \uc57d\uc790\uc785\ub2c8\ub2e4.</p>"},{"location":"README-ko/#_1","title":"\ube60\ub978 \uc2dc\uc791","text":"<p>Compose \ub77c\uc774\ube0c\ub7ec\ub9ac\uc640 \ub124\ud2b8\uc6cc\ud0b9 \ub77c\uc774\ube0c\ub7ec\ub9ac\ub97c \ubd88\ub7ec\uc624\uc138\uc694. :</p> <pre><code>implementation(\"io.coil-kt.coil3:coil-compose:3.4.0\")\nimplementation(\"io.coil-kt.coil3:coil-network-okhttp:3.4.0\")\n</code></pre> <p>\uc774\ubbf8\uc9c0\ub97c \ub85c\ub4dc\ud558\ub824\uba74 <code>AsyncImage</code> Composable\uc744 \uc0ac\uc6a9\ud558\uc138\uc694. :</p> <pre><code>AsyncImage(\n    model = \"https://example.com/image.jpg\",\n    contentDescription = null,\n)\n</code></pre> <p>Coil\uc758 \uc804\uccb4 \ubb38\uc11c\ub294 \uc5ec\uae30\uc5d0\uc11c \ud655\uc778\ud558\uc138\uc694.</p>"},{"location":"README-ko/#_2","title":"\ub77c\uc774\uc120\uc2a4","text":"<pre><code>Copyright 2025 Coil Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   https://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n</code></pre>"},{"location":"README-ru/","title":"README ru","text":"<p>\u0411\u0438\u0431\u043b\u0438\u043e\u0442\u0435\u043a\u0430 \u0437\u0430\u0433\u0440\u0443\u0437\u043a\u0438 \u0438\u0437\u043e\u0431\u0440\u0430\u0436\u0435\u043d\u0438\u0439 \u0434\u043b\u044f Android \u0438 Compose Multiplatform. Coil:</p> <ul> <li>\u0411\u044b\u0441\u0442\u0440\u0430\u044f: Coil \u0432\u044b\u043f\u043e\u043b\u043d\u044f\u0435\u0442 \u0440\u044f\u0434 \u043e\u043f\u0442\u0438\u043c\u0438\u0437\u0430\u0446\u0438\u0439, \u0432\u043a\u043b\u044e\u0447\u0430\u044f \u043a\u044d\u0448\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u0435 \u043f\u0430\u043c\u044f\u0442\u0438 \u0438 \u0434\u0438\u0441\u043a\u0430, \u043f\u043e\u043d\u0438\u0436\u0435\u043d\u0438\u0435 \u0440\u0430\u0437\u0440\u0435\u0448\u0435\u043d\u0438\u044f \u0438\u0437\u043e\u0431\u0440\u0430\u0436\u0435\u043d\u0438\u044f, \u0430\u0432\u0442\u043e\u043c\u0430\u0442\u0438\u0447\u0435\u0441\u043a\u0443\u044e \u043f\u0440\u0438\u043e\u0441\u0442\u0430\u043d\u043e\u0432\u043a\u0443/\u043e\u0442\u043c\u0435\u043d\u0443 \u0437\u0430\u043f\u0440\u043e\u0441\u043e\u0432 \u0438 \u043c\u043d\u043e\u0433\u043e\u0435 \u0434\u0440\u0443\u0433\u043e\u0435.</li> <li>\u041b\u0435\u0433\u043a\u0430\u044f: Coil \u0437\u0430\u0432\u0438\u0441\u0438\u0442 \u0442\u043e\u043b\u044c\u043a\u043e \u043e\u0442 Kotlin, Coroutines \u0438 Okio \u0438 \u0431\u0435\u0437 \u043f\u0440\u043e\u0431\u043b\u0435\u043c \u0440\u0430\u0431\u043e\u0442\u0430\u0435\u0442 \u0441 \u0443\u043a\u043e\u0440\u043e\u0442\u0438\u0442\u0435\u043b\u0435\u043c \u043a\u043e\u0434\u0430 R8 \u043e\u0442 Google.</li> <li>\u041f\u0440\u043e\u0441\u0442\u0430\u044f \u0432 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u0438: API Coil \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u0442 \u0432\u043e\u0437\u043c\u043e\u0436\u043d\u043e\u0441\u0442\u0438 \u044f\u0437\u044b\u043a\u0430 Kotlin \u0434\u043b\u044f \u043f\u0440\u043e\u0441\u0442\u043e\u0442\u044b \u0438 \u043c\u0438\u043d\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0433\u043e \u0448\u0430\u0431\u043b\u043e\u043d\u0430.</li> <li>\u0421\u043e\u0432\u0440\u0435\u043c\u0435\u043d\u043d\u0430\u044f: Coil \u043e\u0440\u0438\u0435\u043d\u0442\u0438\u0440\u043e\u0432\u0430\u043d\u0430 \u043d\u0430 Kotlin \u0438 \u0432\u0437\u0430\u0438\u043c\u043e\u0434\u0435\u0439\u0441\u0442\u0432\u0443\u0435\u0442 \u0441 \u0441\u043e\u0432\u0440\u0435\u043c\u0435\u043d\u043d\u044b\u043c\u0438 \u0431\u0438\u0431\u043b\u0438\u043e\u0442\u0435\u043a\u0430\u043c\u0438, \u0432\u043a\u043b\u044e\u0447\u0430\u044f Compose, Coroutines, Okio, OkHttp \u0438 Ktor.</li> </ul> <p>Coil \u2014 \u044d\u0442\u043e \u0430\u0431\u0431\u0440\u0435\u0432\u0438\u0430\u0442\u0443\u0440\u0430 \u043e\u0442: Coroutine Image Lloader.</p>"},{"location":"README-ru/#_1","title":"\u0411\u044b\u0441\u0442\u0440\u044b\u0439 \u0441\u0442\u0430\u0440\u0442","text":"<p>\u0418\u043c\u043f\u043e\u0440\u0442\u0438\u0440\u0443\u0439\u0442\u0435 \u0431\u0438\u0431\u043b\u0438\u043e\u0442\u0435\u043a\u0443 Compose \u0438 \u0441\u0435\u0442\u0435\u0432\u0443\u044e \u0431\u0438\u0431\u043b\u0438\u043e\u0442\u0435\u043a\u0443:</p> <pre><code>implementation(\"io.coil-kt.coil3:coil-compose:3.4.0\")\nimplementation(\"io.coil-kt.coil3:coil-network-okhttp:3.4.0\")\n</code></pre> <p>\u0427\u0442\u043e\u0431\u044b \u0437\u0430\u0433\u0440\u0443\u0437\u0438\u0442\u0435 \u0438\u0437\u043e\u0431\u0440\u0430\u0436\u0435\u043d\u0438\u0435, \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 <code>AsyncImage</code> composable:</p> <pre><code>AsyncImage(\n    model = \"https://example.com/image.jpg\",\n    contentDescription = null,\n)\n</code></pre> <p>\u041e\u0437\u043d\u0430\u043a\u043e\u043c\u044c\u0442\u0435\u0441\u044c \u0441 \u043f\u043e\u043b\u043d\u043e\u0439 \u0434\u043e\u043a\u0443\u043c\u0435\u043d\u0442\u0430\u0446\u0438\u0435\u0439 Coil \u0437\u0434\u0435\u0441\u044c.</p>"},{"location":"README-ru/#_2","title":"\u041b\u0438\u0446\u0435\u043d\u0437\u0438\u044f","text":"<pre><code>Copyright 2025 Coil Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   https://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n</code></pre>"},{"location":"README-sv/","title":"README sv","text":"<p>Ett bildbibliotek f\u00f6r Android och Compose Multiplatform. Spolen \u00e4r:</p> <ul> <li>Snabb: Coil utf\u00f6r ett antal optimeringar inklusive minne och diskcache, nedsampling av bilden, automatisk paus/avbryt f\u00f6rfr\u00e5gningar och mer.</li> <li>L\u00e4ttvikt: Spolen beror bara p\u00e5 Kotlin, Coroutines och Okio och fungerar s\u00f6ml\u00f6st med Googles R8-kodkrympare.</li> <li>L\u00e4tt att anv\u00e4nda: Coils API utnyttjar Kotlins spr\u00e5kfunktioner f\u00f6r enkelhet och minimal konstruktion.</li> <li>Modern: Coil \u00e4r Kotlin-f\u00f6rst och samverkar med moderna bibliotek inklusive Compose, Coroutines, Okio, OkHttp och Ktor.</li> </ul> <p>Spole \u00e4r en akronym f\u00f6r: Corutin Ibild Lloader.</p>"},{"location":"README-sv/#snabbstart","title":"Snabbstart","text":"<p>Importera Compose-biblioteket och ett n\u00e4tverksbibliotek:</p> <pre><code>implementation(\"io.coil-kt.coil3:coil-compose:3.4.0\")\nimplementation(\"io.coil-kt.coil3:coil-network-okhttp:3.4.0\")\n</code></pre> <p>F\u00f6r att ladda en bild, anv\u00e4nd \"AsyncImage\" komponerbar:</p> <pre><code>AsyncImage(\n    model = \"https://example.com/image.jpg\",\n    contentDescription = null,\n)\n</code></pre> <p>Kolla in Coils fullst\u00e4ndiga dokumentation h\u00e4r.</p>"},{"location":"README-sv/#license","title":"License","text":"<pre><code>Copyright 2025 Coil Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   https://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n</code></pre>"},{"location":"README-tr/","title":"README tr","text":"<p>Android ve Compose Multiplatform i\u00e7in bir resim y\u00fckleme k\u00fct\u00fcphanesi. Coil:</p> <ul> <li>H\u0131zl\u0131: Coil, bellek ve disk \u00f6nbelle\u011fe alma, resmin alt \u00f6rneklemesini yapma, istekleri otomatik olarak duraklatma/iptal etme ve daha fazlas\u0131 dahil olmak \u00fczere bir dizi optimizasyon ger\u00e7ekle\u015ftirir.</li> <li>Hafif: Coil yaln\u0131zca Kotlin, Coroutines ve Okio'ya ba\u011fl\u0131d\u0131r ve Google'\u0131n R8 kod k\u00fc\u00e7\u00fclt\u00fcc\u00fcs\u00fcyle sorunsuz bir \u015fekilde \u00e7al\u0131\u015f\u0131r.</li> <li>Kullan\u0131m\u0131 kolay: Coil'in API'si, basitlik ve minimum kal\u0131p i\u00e7in Kotlin'in dil \u00f6zelliklerini kullan\u0131r.</li> <li>Modern: Coil, Kotlin \u00f6nceliklidir ve Compose, Coroutines, Okio, OkHttp ve Ktor gibi modern k\u00fct\u00fcphanelerle birlikte \u00e7al\u0131\u015f\u0131r.</li> </ul> <p>Coil, Coroutine Image Loader'\u0131n k\u0131saltmas\u0131d\u0131r.</p>"},{"location":"README-tr/#hzl-baslangc","title":"H\u0131zl\u0131 Ba\u015flang\u0131\u00e7","text":"<p>Compose k\u00fct\u00fcphanesini ve bir a\u011f k\u00fct\u00fcphanesini i\u00e7e aktar\u0131n:</p> <pre><code>implementation(\"io.coil-kt.coil3:coil-compose:3.4.0\")\nimplementation(\"io.coil-kt.coil3:coil-network-okhttp:3.4.0\")\n</code></pre> <p>Bir g\u00f6r\u00fcnt\u00fcy\u00fc y\u00fcklemek i\u00e7in, <code>AsyncImage</code> bile\u015fenini kullan\u0131n:</p> <pre><code>AsyncImage(\n    model = \"https://example.com/image.jpg\",\n    contentDescription = null,\n)\n</code></pre> <p>Coil'in tam belgelerine buradan g\u00f6z at\u0131n.</p>"},{"location":"README-tr/#lisans","title":"Lisans","text":"<pre><code>Copyright 2025 Coil Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   https://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n</code></pre>"},{"location":"README-uz/","title":"README uz","text":"<p>Android va Compose Multiplatform uchun rasm yuklash kutubxonasi. Coil quyidagi xususiyatlarga ega:</p> <ul> <li>Tez: Coil bir qancha optimallashtirishlarni amalga oshiradi: xotira va disk keshini ishlatadi, rasmlarni kichraytiradi (downsampling), so\u2018rovlarni avtomatik to\u2018xtatadi yoki bekor qiladi va boshqalar.</li> <li>Yengil: Coil faqat Kotlin, Coroutine'lar va Okio'ga bog\u2018liq bo\u2018lib, Google'ning R8 kod qisqartiruvchisi bilan to\u2018liq mos ishlaydi.</li> <li>Foydalanish oson: Coil API'lari Kotlin tilining imkoniyatlaridan foydalanib, minimal kod bilan ishlashni ta'minlaydi.</li> <li>Zamonaviy: Coil Kotlin-birinchi yondashuvga asoslangan va Compose, Coroutines, Okio, OkHttp, va Ktor kabi zamonaviy kutubxonalar bilan mos ishlaydi.</li> </ul> <p>Coil so\u2018zi qisqartma bo\u2018lib, quyidagini anglatadi: Coroutine Image Loader.</p>"},{"location":"README-uz/#foylanishni-boshlash","title":"Foylanishni boshlash","text":"<p>Coil Compose kutubxonasi va tarmoq kutubxonasini yuklang:</p> <pre><code>implementation(\"io.coil-kt.coil3:coil-compose:3.4.0\")\nimplementation(\"io.coil-kt.coil3:coil-network-okhttp:3.4.0\")\n</code></pre> <p>Rasm yuklash uchun <code>AsyncImage</code> composable'dan foydalaning:</p> <p><pre><code>AsyncImage(\n    model = \"https://example.com/image.jpg\",\n    contentDescription = null,\n)\n</code></pre> Coil haqidagi to\u2018liq dokumentatsiyani ko'rib chiqing.</p>"},{"location":"README-uz/#litsenziya","title":"Litsenziya","text":"<pre><code>Copyright 2025 Coil Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   https://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n</code></pre>"},{"location":"README-zh/","title":"README zh","text":"<p>\u9002\u7528\u4e8e Android \u548c Compose Multiplatform \u7684\u56fe\u50cf\u52a0\u8f7d\u5e93\u3002Coil \u5177\u6709\u4ee5\u4e0b\u7279\u70b9\uff1a</p> <ul> <li>\u5feb\u901f\uff1aCoil \u6267\u884c\u591a\u9879\u4f18\u5316\uff0c\u5305\u62ec\u5185\u5b58\u548c\u78c1\u76d8\u7f13\u5b58\u3001\u56fe\u50cf\u964d\u91c7\u6837\u3001\u81ea\u52a8\u6682\u505c/\u53d6\u6d88\u8bf7\u6c42\u7b49\u3002</li> <li>\u8f7b\u91cf\uff1aCoil \u4ec5\u4f9d\u8d56\u4e8e Kotlin\u3001Coroutines \u548c Okio\uff0c\u53ef\u4e0e Google \u7684 R8 \u4ee3\u7801\u538b\u7f29\u5668\u65e0\u7f1d\u534f\u4f5c\u3002</li> <li>\u6613\u4e8e\u4f7f\u7528\uff1aCoil \u7684 API \u5229\u7528 Kotlin \u7684\u8bed\u8a00\u529f\u80fd\u5b9e\u73b0\u7b80\u5355\u6027\u5e76\u51cf\u5c11\u6837\u677f\u4ee3\u7801\u3002</li> <li>\u73b0\u4ee3\uff1aCoil \u662f Kotlin \u4f18\u5148\u7684\uff0c\u53ef\u4e0e\u5305\u62ec Compose\u3001Coroutines\u3001Okio\u3001OkHttp \u548c Ktor \u5728\u5185\u7684\u73b0\u4ee3\u5e93\u4e92\u64cd\u4f5c\u3002</li> </ul> <p>Coil \u662f Coroutine Image Loader \u7684\u7f29\u5199\u3002</p>"},{"location":"README-zh/#_1","title":"\u5feb\u901f\u5165\u95e8","text":"<p>\u5bfc\u5165 Compose \u5e93\u548c \u7f51\u7edc\u5e93\uff1a</p> <pre><code>implementation(\"io.coil-kt.coil3:coil-compose:3.4.0\")\nimplementation(\"io.coil-kt.coil3:coil-network-okhttp:3.4.0\")\n</code></pre> <p>\u8981\u52a0\u8f7d\u56fe\u50cf\uff0c\u8bf7\u4f7f\u7528 <code>AsyncImage</code>\u53ef\u7ec4\u5408\uff1a</p> <pre><code>AsyncImage(\n    model = \"https://example.com/image.jpg\",\n    contentDescription = null,\n)\n</code></pre> <p>\u67e5\u770b Coil \u7684\u5b8c\u6574\u6587\u6863\u3002</p>"},{"location":"README-zh/#license","title":"License","text":"<pre><code>Copyright 2025 Coil Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   https://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n</code></pre>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#340-february-24-2026","title":"[3.4.0] - February 24, 2026","text":"<ul> <li>New: Add <code>ConcurrentRequestStrategy</code> to support combining in-flight network requests for the same key. (#2995, #3326)<ul> <li><code>DeDupeConcurrentRequestStrategy</code> enables this behavior and lets waiters wait for the results of an in-flight network request.<ul> <li>This behavior is experimental and is currently disabled by default.</li> <li>Currently, requests are always combined based on their <code>diskCacheKey</code>.</li> </ul> </li> <li><code>OkHttpNetworkFetcherFactory</code>, <code>KtorNetworkFetcherFactory</code>, and <code>NetworkFetcher.Factory</code> now accept <code>concurrentRequestStrategy</code>.</li> </ul> </li> <li>New: Decode images on JS/WASM using a web worker to avoid blocking the browser main thread. (#3305)</li> <li>New: Add support for Linux native targets (<code>linuxX64</code> and <code>linuxArm64</code>) for non-Compose multiplatform artifacts. (#3054)</li> <li>New: Add Compose-only APIs to improve transitions between subsequent requests. (#3141, #3175)<ul> <li><code>ImageRequest.Builder.useExistingImageAsPlaceholder</code> enables crossfading from the previous image when no placeholder is set.</li> <li><code>ImageRequest.Builder.preferEndFirstIntrinsicSize</code> lets <code>CrossfadePainter</code> prefer the end painter's intrinsic size.</li> </ul> </li> <li>New: Add <code>ImageLoader.Builder.repeatCount(Int)</code> in <code>coil-gif</code> to set a global animated image repeat count. (#3143)</li> <li>New: Add support for preferring embedded video thumbnails in <code>coil-video</code>. (#3107)</li> <li>New: Publish <code>coil-lint</code> with <code>coil-core</code> and add a lint check to catch accidental <code>kotlin.error()</code> calls in <code>ImageRequest.Builder</code> blocks. (#3304)</li> <li>Set Kotlin language version to 2.1. (#3302)</li> <li>Make <code>BitmapFetcher</code> available in common code. (#3286)</li> <li>Use <code>applicationContext</code> when creating the singleton <code>ImageLoader</code> on Android. (#3246)</li> <li>Cache eligible non-2xx HTTP responses by default (e.g. <code>404</code>) and stop caching non-cacheable responses (e.g. <code>500</code>). (#3137, #3139)</li> <li>Fix potential race condition when consuming OkHttp response bodies. (#3186)</li> <li>Fix <code>maxBitmapSize</code> edge case to prevent oversized bitmap crashes on Android. (#3259)</li> <li>Update Kotlin to 2.3.10.</li> <li>Update Compose to 1.9.3.</li> <li>Update Okio to 3.16.4.</li> <li>Update Skiko to 0.9.22.2.</li> <li>Update <code>kotlinx-io-okio</code> to 0.9.0.</li> <li>Update <code>androidx.core</code> to 1.16.0.</li> <li>Update <code>androidx.lifecycle</code> to 2.9.4.</li> <li>Update <code>androidx.exifinterface</code> to 1.4.2.</li> </ul>"},{"location":"changelog/#330-july-22-2025","title":"[3.3.0] - July 22, 2025","text":"<ul> <li>New: Introduce a new API to limit <code>MemoryCache.maxSize</code> on Android while the app is backgrounded.<ul> <li>If <code>ImageLoader.Builder.memoryCacheMaxSizePercentWhileInBackground</code> is set, the <code>ImageLoader</code>'s memory cache will be limited to a percent of its max size while the app is backgrounded. This setting is currently disabled by default.</li> <li>Images will be trimmed from the memory cache to reach the limited max size when the app is backgrounded, however the memory cache's weak references to recently trimmed images are unaffected. This means if an image is currently referenced elsewhere (e.g. <code>AsyncImage</code>, <code>ImageView</code>, etc.) it will still be present in the memory cache.</li> <li>This API is useful to reduce background memory usage, keep your app from being killed earlier, and help reduce memory pressure on your users' devices.</li> </ul> </li> <li>New: Add an <code>Svg.Parser</code> argument to <code>SvgDecoder</code>.<ul> <li>This enables using custom SVG parsers if the default SVG parser doesn't meet your needs.</li> </ul> </li> <li>Add a <code>density</code> argument to <code>SvgDecoder</code> to support providing a custom density multiplier.</li> <li>Add <code>Uri.Builder</code> to support copying and modifying <code>Uri</code>s.</li> <li>Add <code>ImageLoader.Builder.mainCoroutineContext</code> to support overriding Coil's <code>Dispatchers.main.immediate</code> usage in tests.</li> <li>Fix <code>CrossfadePainter.intrinsicSize</code> changing when the <code>start</code> image is dereferenced at the end of the animation. This aligns with the behaviour of <code>CrossfadeDrawable</code>.</li> <li>Fix <code>ImageLoaders.executeBlocking</code> being inaccessible from Java.</li> <li>Use <code>kotlinx.io</code>'s Okio interop module in <code>coil-network-ktor3</code>.</li> <li>Update <code>kotlinx-datetime</code> to <code>0.7.1</code>.<ul> <li>This release includes binary incompatible changes that only affect the <code>coil-network-cache-control</code> module. See here for more info.</li> </ul> </li> <li>Update Kotlin to 2.2.0.</li> <li>Update Compose to 1.8.2.</li> <li>Update Okio to 3.15.0.</li> <li>Update Skiko to 0.9.4.2.</li> </ul>"},{"location":"changelog/#320-may-13-2025","title":"[3.2.0] - May 13, 2025","text":"<p>Changes since <code>3.1.0</code>:</p> <ul> <li>Important: <code>coil-compose</code> and <code>coil-compose-core</code> now require Java 11 bytecode due to Compose <code>1.8.0</code> requiring it. See here for how to enable it.</li> <li>Change <code>AsyncImagePreviewHandler</code>'s functional constructor to return <code>AsyncImagePainter.State.Success</code> instead of <code>AsyncImagePainter.State.Loading</code>.</li> <li>Fix cancellation in <code>ConstraintsSizeResolver#size()</code>.</li> <li>Fix warning for missing <code>PlatformContext</code> when building with R8.</li> <li>Fix <code>FakeImageLoaderEngine</code> not setting <code>Transition.Factory.NONE</code> when the default <code>FakeImageLoaderEngine</code> response is returned.</li> <li>Remove experimental annotation from <code>ColorImage</code>.</li> <li>Parse network headers lazily in <code>CacheControlCacheStrategy</code>.</li> <li>Refactor <code>CircleCropTransformation</code> and <code>RoundedCornersTransformation</code> to share common code.</li> <li>Fall back to using <code>BitmapFactory</code> internally if <code>ExifOrientationStrategy</code> is not <code>RESPECT_PERFORMANCE</code>.</li> <li>Update Kotlin to 2.1.20.</li> <li>Update Compose to 1.8.0.</li> <li>Update Okio to 3.11.0.</li> <li>Update Skiko to 0.9.4.</li> <li>Update Coroutines to 1.10.2.</li> <li>Update <code>accompanist-drawablepainter</code> to 0.37.3.</li> </ul> <p>Changes since <code>3.2.0-rc02</code>:</p> <ul> <li>Fall back to using <code>BitmapFactory</code> internally if <code>ExifOrientationStrategy</code> is not <code>RESPECT_PERFORMANCE</code>.</li> <li>Update Compose to 1.8.0.</li> <li>Update <code>accompanist-drawablepainter</code> to 0.37.3.</li> </ul>"},{"location":"changelog/#320-rc02-april-26-2025","title":"[3.2.0-rc02] - April 26, 2025","text":"<ul> <li>Fix image requests failing with <code>ClosedByteChannelException</code> when loading an image with <code>KtorNetworkFetcherFactory</code> (Ktor 3) on non-JVM targets.</li> </ul>"},{"location":"changelog/#320-rc01-april-24-2025","title":"[3.2.0-rc01] - April 24, 2025","text":"<ul> <li>Important: <code>coil-compose</code> and <code>coil-compose-core</code> now require Java 11 bytecode due to Compose <code>1.8.0</code> requiring it. See here for how to enable it.</li> <li>Change <code>AsyncImagePreviewHandler</code>'s functional constructor to return <code>AsyncImagePainter.State.Success</code> instead of <code>AsyncImagePainter.State.Loading</code>.</li> <li>Fix cancellation in <code>ConstraintsSizeResolver#size()</code>.</li> <li>Fix warning for missing <code>PlatformContext</code> when building with R8.</li> <li>Fix <code>FakeImageLoaderEngine</code> not setting <code>Transition.Factory.NONE</code> when the default <code>FakeImageLoaderEngine</code> response is returned.</li> <li>Remove experimental annotation from <code>ColorImage</code>.</li> <li>Parse network headers lazily in <code>CacheControlCacheStrategy</code>.</li> <li>Refactor <code>CircleCropTransformation</code> and <code>RoundedCornersTransformation</code> to share common code.</li> <li>Use <code>kotlinx.io</code>'s Okio interop module in <code>coil-network-ktor2</code> and <code>coil-network-ktor3</code>.</li> <li>Update Kotlin to 2.1.20.</li> <li>Update Compose to 1.8.0-rc01.</li> <li>Update Okio to 3.11.0.</li> <li>Update Skiko to 0.9.4.</li> <li>Update Coroutines to 1.10.2.</li> </ul>"},{"location":"changelog/#310-february-4-2025","title":"[3.1.0] - February 4, 2025","text":"<ul> <li>Improve <code>AsyncImage</code> performance.<ul> <li>Runtime performance is improved by 25% to 40% depending on if the composable is being instantiated or reused. Allocations are also reduced by 35% to 48%. More info here.</li> </ul> </li> <li>Add <code>ColorImage</code> and deprecate <code>FakeImage</code>.<ul> <li><code>ColorImage</code> is useful for returning a fake value in tests and previews. It solves the same use case as <code>FakeImage</code>, but is more easily accessible in <code>coil-core</code> instead of <code>coil-test</code>.</li> </ul> </li> <li>Remove <code>coil-compose-core</code>'s dependency on <code>Dispatchers.Main.immedate</code>.<ul> <li>This also fixes a case where <code>AsyncImagePainter</code> would not execute <code>ImageRequest</code>s synchronously in Paparazzi and Roborazzi screenshot tests.</li> </ul> </li> <li>Add support for data URIs with the format: <code>data:[&lt;mediatype&gt;][;base64],&lt;data&gt;</code></li> <li>Add <code>AnimatedImageDecoder.ENCODED_LOOP_COUNT</code> to support using the encoded repeat count in a GIF's metadata.</li> <li>Add <code>Extras</code> to <code>NetworkRequest</code> to support custom extensions.</li> <li>Add <code>DiskCache.Builder.cleanupCoroutineContext</code> and deprecate <code>DiskCache.Builder.cleanupDispatcher</code>.</li> <li>Add <code>ImageLoader.Builder.imageDecoderEnabled</code> to optionally disable using <code>android.graphics.ImageDecoder</code> on API 29 and above.</li> <li>Log a warning if there is no registered <code>Keyer</code> for an <code>ImageRequest</code>'s data type.</li> <li>Make <code>CrossfadePainter</code> public.</li> <li>Support <code>Transformation</code>s on all multiplatform targets.</li> <li>Support 0 as <code>Expires</code> header value in <code>CacheControlCacheStrategy</code>.</li> <li>Fix <code>AsyncImage</code>/<code>SubcomposeAsyncImage</code>/<code>rememberAsyncImage</code> not launching a new <code>ImageRequest</code> if its <code>ContentScale</code> changes to/from <code>None</code>.</li> <li>Update Kotlin to 2.1.10.<ul> <li>NOTE: This release requires compiling with Kotlin 2.1.0 or greater if you use Kotlin native due to an LLVM update.</li> </ul> </li> <li>Update Compose to 1.7.3.</li> <li>Update <code>androidx.core</code> to 1.15.0.</li> </ul>"},{"location":"changelog/#304-november-25-2024","title":"[3.0.4] - November 25, 2024","text":"<ul> <li>Fix vector drawables not rendering in the Android Studio preview.</li> <li>Fix potential memory cache miss for requests whose size exceeds <code>maxBitmapSize</code>.</li> <li>Fix <code>FakeImage</code> not rendering on Android.</li> <li>Fix not launching a new image request when the request's <code>Transformation</code>s change when used with <code>AsyncImage</code>/<code>rememberAsyncImagePainter</code>/<code>SubcomposeAsyncImage</code>.</li> <li>Fix <code>ScaleDrawable</code> and <code>CrossfadeDrawable</code> not respecting tint states.</li> <li>Allow <code>ImageDecoder</code> to decode partial image sources. This matches the behavior in <code>BitmapFactory</code>.</li> <li>Fix <code>Bitmap.prepareToDraw()</code> not being called after decoding.</li> <li><code>SvgDecoder</code> should not return <code>isSampled = true</code> for non-rasterized images.</li> <li>Fall back to <code>Dispatchers.Unconfined</code> in Compose if an immediate main dispatcher is unavailable. This is only used in preview/test environments.</li> <li>Update Ktor 2 to <code>2.3.13</code>.</li> </ul>"},{"location":"changelog/#303-november-14-2024","title":"[3.0.3] - November 14, 2024","text":"<ul> <li>Fix setting <code>ImageRequest.scale</code> based on an <code>ImageView</code>'s <code>ScaleType</code>.</li> <li>Fix edge case where <code>DiskCache</code> would not track removal of an entry after deleting its files.</li> <li>Pass throwable to <code>Logger</code> when logging errors.</li> <li>Don't replace <code>kotlin-stdlib-jdk7</code> and <code>kotlin-stdlib-jdk8</code> with <code>kotlin-stdlib</code>.</li> </ul>"},{"location":"changelog/#302-november-9-2024","title":"[3.0.2] - November 9, 2024","text":"<ul> <li>Fix crash when invoking <code>OkHttpNetworkFetcherFactory</code> with a custom <code>CacheStrategy</code> on Android.</li> <li>Fix <code>CacheControlCacheStrategy</code> computing the age of a cache entry incorrectly.</li> <li>Fix case where <code>ImageRequest.bitmapConfig</code> would only be respected on &gt;= API 28 if it was <code>ARGB_8888</code> or <code>HARDWARE</code>.</li> </ul>"},{"location":"changelog/#301-november-7-2024","title":"[3.0.1] - November 7, 2024","text":"<ul> <li>Fix crash when calling <code>Image.toBitmap</code> with a hardware bitmap-backed <code>BitmapImage</code>.</li> <li>Fix <code>AsyncImageModelEqualityDelegate.Default</code> comparing equality incorrectly for non-<code>ImageRequest</code> models.</li> </ul>"},{"location":"changelog/#300-november-4-2024","title":"[3.0.0] - November 4, 2024","text":"<p>Coil 3.0.0 is the next major release of Coil with full support for Compose Multiplatform.</p> <p>For the full list of improvements and important changes in 3.0.0, check out the upgrade guide.</p> <p>Changes since <code>3.0.0-rc02</code>:</p> <ul> <li>Remove remaining deprecated methods.</li> </ul>"},{"location":"changelog/#300-rc02-october-28-2024","title":"[3.0.0-rc02] - October 28, 2024","text":"<p>For the full list of improvements and important changes in 3.x, check out the upgrade guide. Changes since <code>3.0.0-rc01</code>:</p> <ul> <li>Add <code>BlackholeDecoder</code>. This simplifies disk-cache only preloading.</li> <li>Add <code>remember</code> functions for <code>ConstraintsSizeResolver</code> and <code>DrawScopeSizeResolver</code>.</li> <li>Remove <code>EqualityDelegate</code> as a parameter to <code>AsyncImage</code>. Instead, it should be set through <code>LocalAsyncImageModelEqualityDelegate</code>.</li> <li>Fix <code>AsyncImage</code> not rendering when parent composable uses <code>IntrinsicSize</code>.</li> <li>Fix <code>AsyncImage</code> filling the available constraints when <code>AsyncImagePainter</code> has no child painter.</li> <li>Fix <code>rememberAsyncImagePainter</code> recomposing infinitely when its state is observed due to <code>EqualityDelegate</code> being ignored.</li> <li>Fix parsing <code>File</code>/<code>Path</code> paths with special characters.</li> <li>Fix using custom <code>FileSystem</code> implementations with <code>VideoFrameDecoder</code>.</li> <li>Update Ktor to <code>3.0.0</code>.</li> <li>Update <code>androidx.annotation</code> to <code>1.9.0</code>.</li> </ul>"},{"location":"changelog/#300-rc01-october-8-2024","title":"[3.0.0-rc01] - October 8, 2024","text":"<p>For the full list of improvements and important changes in 3.x, check out the upgrade guide. Changes since <code>3.0.0-alpha10</code>:</p> <ul> <li>BREAKING Disable <code>addLastModifiedToFileCacheKey</code> by default and allow it to be set per request. The behaviour can be reenabled with the same flag.</li> <li>New: Introduce a new <code>coil-network-cache-control</code> artifact, which implements <code>Cache-Control</code> header support.</li> <li>New: Add <code>scaleToDensity</code> property to <code>SvgDecoder.Factory</code>. This property ensure SVGs with intrinsic dimensions are multiplied by the devices density (only supported on Android).</li> <li>Rename <code>ExifOrientationPolicy</code> to <code>ExifOrientationStrategy</code>.</li> <li>Remove unshareable images from the <code>MemoryCache</code> on get.</li> <li>Make <code>ConstraintsSizeResolver</code> public.</li> <li>Stabilize <code>setSingletonImageLoaderFactory</code>.</li> <li>Restore optimized JVM I/O functions in <code>coil-network-ktor3</code></li> <li>Add <code>pdf</code> to list of mime types.</li> <li>Update compile sdk to 35.</li> <li>Update Kotlin to 2.0.20.</li> <li>Update Okio to 3.9.1.</li> </ul>"},{"location":"changelog/#300-alpha10-august-7-2024","title":"[3.0.0-alpha10] - August 7, 2024","text":"<ul> <li>BREAKING: Replace <code>ImageLoader.Builder.networkObserverEnabled</code> with a <code>ConnectivityChecker</code> interface for <code>NetworkFetcher</code>.<ul> <li>To disable the network observer, pass <code>ConnectivityChecker.ONLINE</code> to the constructor for <code>KtorNetworkFetcherFactory</code>/<code>OkHttpNetworkFetcherFactory</code>.</li> </ul> </li> <li>New: Support loading Compose Multiplatform resources on all platforms. To load a resource, use <code>Res.getUri</code>:</li> </ul> <pre><code>AsyncImage(\n    model = Res.getUri(\"drawable/image.jpg\"),\n    contentDescription = null,\n)\n</code></pre> <ul> <li>Add <code>maxBitmapSize</code> property to <code>ImageLoader</code> and <code>ImageRequest</code>.<ul> <li>This property defaults to 4096x4096 and provides a safe upper bound for the dimensions of an allocated bitmap. This helps accidentally loading very large images with <code>Size.ORIGINAL</code> and causing an out of memory exception.</li> </ul> </li> <li>Convert <code>ExifOrientationPolicy</code> to be an interface to support custom policies.</li> <li>Fix <code>Uri</code> handling of Windows file paths.</li> <li>Remove <code>@ExperimentalCoilApi</code> from the <code>Image</code> APIs.</li> <li>Update Kotlin to 2.0.10.</li> </ul>"},{"location":"changelog/#300-alpha09-july-23-2024","title":"[3.0.0-alpha09] - July 23, 2024","text":"<ul> <li>BREAKING: Rename the <code>io.coil-kt.coil3:coil-network-ktor</code> artifact to <code>io.coil-kt.coil3:coil-network-ktor2</code> which depends on Ktor 2.x. Additionally, introduce <code>io.coil-kt.coil3:coil-network-ktor3</code> which depends on Ktor 3.x. <code>wasmJs</code> support is only available in Ktor 3.x.</li> <li>New: Add <code>AsyncImagePainter.restart()</code> to manually restart an image request.</li> <li>Remove <code>@ExperimentalCoilApi</code> from <code>NetworkClient</code> and related classes.</li> <li>Optimize <code>ImageRequest</code> to avoid unnecessary <code>Extras</code> and <code>Map</code> allocations.</li> </ul>"},{"location":"changelog/#270-july-17-2024","title":"[2.7.0] - July 17, 2024","text":"<ul> <li>Slightly optimize internal coroutines usage to improve the performance of <code>ImageLoader.execute</code>, <code>AsyncImage</code>, <code>SubcomposeAsyncImage</code>, and <code>rememberAsyncImagePainter</code>. (#2205)</li> <li>Fix duplicate network calls for chunked responses. (#2363)</li> <li>Update Kotlin to 2.0.0.</li> <li>Update Compose UI to 1.6.8.</li> <li>Update Okio to 3.9.0.</li> </ul>"},{"location":"changelog/#300-alpha08-july-8-2024","title":"[3.0.0-alpha08] - July 8, 2024","text":"<ul> <li>BREAKING: Rename <code>ImageRequest</code> and <code>ImageLoader</code> <code>dispatcher</code> methods to <code>coroutineContext</code>. For instance, <code>ImageRequest.Builder.dispatcher</code> is now <code>ImageRequest.Builder.coroutineContext</code>. This was renamed as the method now accepts any <code>CoroutineContext</code> and no longer requires a <code>Dispatcher</code>.</li> <li>Fix: Fix <code>IllegalStateException: Reading a state that was created after the snapshot was taken or in a snapshot that has not yet been applied</code> which could occur due to a race condition.<ul> <li>NOTE: This reintroduces a soft dependency on <code>Dispatchers.Main.immediate</code>. As a result you should re-add a dependency on <code>kotlinx-coroutines-swing</code> on JVM. If it's not imported then <code>ImageRequest</code>s won't be dispatched immediately and will have one frame of delay before setting the <code>ImageRequest.placeholder</code> or resolving from the memory cache.</li> </ul> </li> </ul>"},{"location":"changelog/#300-alpha07-june-26-2024","title":"[3.0.0-alpha07] - June 26, 2024","text":"<ul> <li>BREAKING: <code>AsyncImagePainter</code> no longer waits for <code>onDraw</code> by default and instead uses <code>Size.ORIGINAL</code>.<ul> <li>This fixes compatibility issues with Roborazzi/Paparazzi and overall improves test reliability.</li> <li>To revert back to waiting for <code>onDraw</code>, set <code>DrawScopeSizeResolver</code> as your <code>ImageRequest.sizeResolver</code>.</li> </ul> </li> <li>BREAKING: Refactor the multiplatform <code>Image</code> API. Notably, <code>asCoilImage</code> has been renamed to <code>asImage</code>.</li> <li>BREAKING: <code>AsyncImagePainter.state</code> has been changed to <code>StateFlow&lt;AsyncImagePainter.State&gt;</code>. Use <code>collectAsState</code> to observe its value. This improves performance.</li> <li>BREAKING: <code>AsyncImagePainter.imageLoader</code> and <code>AsyncImagePainter.request</code> have been combined into <code>StateFlow&lt;AsyncImagePainter.Inputs&gt;</code>. Use <code>collectAsState</code> to observe its value. This improves performance.</li> <li>BREAKING: Remove support for <code>android.resource://example.package.name/drawable/image</code> URIs as it prevents resource shrinking optimizations.<ul> <li>If you still needs its functionality you can manually include <code>ResourceUriMapper</code> in your component registry.</li> </ul> </li> <li>New: Introduce <code>AsyncImagePreviewHandler</code> to support controlling <code>AsyncImagePainter</code>'s preview rendering behavior.<ul> <li>Use <code>LocalAsyncImagePreviewHandler</code> to override the preview behavior.</li> <li>As part of this change and other <code>coil-compose</code> improvements, <code>AsyncImagePainter</code> now attempts to execute execute the <code>ImageRequest</code> by default instead of defaulting to displaying <code>ImageRequest.placeholder</code>. Requests that use the network or files are expected to fail in the preview environment, however Android resources should work.</li> </ul> </li> <li>New: Support extracting video image by frame index. (#2183)</li> <li>New: Support passing <code>CoroutineContext</code> to any <code>CoroutineDispatcher</code> methods. (#2241).</li> <li>New: Support the weak reference memory cache on JS and WASM JS.</li> <li>Don't dispatch to <code>Dispatchers.Main.immediate</code> in Compose. As a side-effect, <code>kotlinx-coroutines-swing</code> no longer needs to be imported on JVM.</li> <li>Don't call <code>async</code> and create a disposable in Compose to improve performance (thanks @mlykotom!). (#2205)</li> <li>Fix passing global <code>ImageLoader</code> extras to <code>Options</code>. (#2223)</li> <li>Fix <code>crossfade(false)</code> not working on non-Android targets.</li> <li>Fix VP8X feature flags byte offset (#2199).</li> <li>Convert <code>SvgDecoder</code> on non-Android targets to render to a bitmap instead of render the image at draw-time. This improves performance.<ul> <li>This behavior can be controlled using <code>SvgDecoder(renderToBitmap)</code>.</li> </ul> </li> <li>Move <code>ScaleDrawable</code> from <code>coil-gif</code> to <code>coil-core</code>.</li> <li>Update Kotlin to 2.0.0.</li> <li>Update Compose to 1.6.11.</li> <li>Update Okio to 3.9.0.</li> <li>Update Skiko to 0.8.4.</li> <li>For the full list of important changes in 3.x, check out the upgrade guide.</li> </ul>"},{"location":"changelog/#300-alpha06-february-29-2024","title":"[3.0.0-alpha06] - February 29, 2024","text":"<ul> <li>Downgrade Skiko to 0.7.93.</li> <li>For the full list of important changes in 3.x, check out the upgrade guide.</li> </ul>"},{"location":"changelog/#300-alpha05-february-28-2024","title":"[3.0.0-alpha05] - February 28, 2024","text":"<ul> <li>New: Support the <code>wasmJs</code> target.</li> <li>Create <code>DrawablePainter</code> and <code>DrawableImage</code> to support drawing <code>Image</code>s that aren't backed by a <code>Bitmap</code> on non-Android platforms.<ul> <li>The <code>Image</code> APIs are experimental and likely to change between alpha releases.</li> </ul> </li> <li>Update <code>ContentPainterModifier</code> to implement <code>Modifier.Node</code>.</li> <li>Fix: Lazily register component callbacks and the network observer on a background thread. This fixes slow initialization that would typically occur on the main thread.</li> <li>Fix: Fix <code>ImageLoader.Builder.placeholder/error/fallback</code> not being used by <code>ImageRequest</code>.</li> <li>Update Compose to 1.6.0.</li> <li>Update Coroutines to 1.8.0.</li> <li>Update Okio to 3.8.0.</li> <li>Update Skiko to 0.7.94.</li> <li>For the full list of important changes in 3.x, check out the upgrade guide.</li> </ul>"},{"location":"changelog/#260-february-23-2024","title":"[2.6.0] - February 23, 2024","text":"<ul> <li>Make <code>rememberAsyncImagePainter</code>, <code>AsyncImage</code>, and <code>SubcomposeAsyncImage</code> restartable and skippable. This improves performance by avoiding recomposition unless one of the composable's arguments changes.<ul> <li>Add an optional <code>modelEqualityDelegate</code> argument to <code>rememberAsyncImagePainter</code>, <code>AsyncImage</code>, and <code>SubcomposeAsyncImage</code> to control whether the <code>model</code> will trigger a recomposition.</li> </ul> </li> <li>Update <code>ContentPainterModifier</code> to implement <code>Modifier.Node</code>.</li> <li>Fix: Lazily register component callbacks and the network observer on a background thread. This fixes slow initialization that would typically occur on the main thread.</li> <li>Fix: Avoid relaunching a new image request in <code>rememberAsyncImagePainter</code>, <code>AsyncImage</code>, and <code>SubcomposeAsyncImage</code> if <code>ImageRequest.listener</code> or <code>ImageRequest.target</code> change.</li> <li>Fix: Don't observe the image request twice in <code>AsyncImagePainter</code>.</li> <li>Update Kotlin to 1.9.22.</li> <li>Update Compose to 1.6.1.</li> <li>Update Okio to 3.8.0.</li> <li>Update <code>androidx.collection</code> to 1.4.0.</li> <li>Update <code>androidx.lifecycle</code> to 2.7.0.</li> </ul>"},{"location":"changelog/#300-alpha04-february-1-2024","title":"[3.0.0-alpha04] - February 1, 2024","text":"<ul> <li>Breaking: Remove <code>Lazy</code> from <code>OkHttpNetworkFetcherFactory</code> and <code>KtorNetworkFetcherFactory</code>'s public API.</li> <li>Expose <code>Call.Factory</code> instead of <code>OkHttpClient</code> in <code>OkHttpNetworkFetcherFactory</code>.</li> <li>Convert <code>NetworkResponseBody</code> to wrap a <code>ByteString</code>.</li> <li>Downgrade Compose to 1.5.12.</li> <li>For the full list of important changes, check out the upgrade guide.</li> </ul>"},{"location":"changelog/#300-alpha03-january-20-2024","title":"[3.0.0-alpha03] - January 20, 2024","text":"<ul> <li>Breaking: <code>coil-network</code> has been renamed to <code>coil-network-ktor</code>. Additionally, there is a new <code>coil-network-okhttp</code> artifact that depends on OkHttp and doesn't require specifying a Ktor engine.<ul> <li>Depending on which artifact you import you can reference the <code>Fetcher.Factory</code> manually using <code>KtorNetworkFetcherFactory</code> or <code>OkHttpNetworkFetcherFactory</code>.</li> </ul> </li> <li>Support loading <code>NSUrl</code> on Apple platforms.</li> <li>Add <code>clipToBounds</code> parameter to <code>AsyncImage</code>.</li> <li>For the full list of important changes, check out the upgrade guide.</li> </ul>"},{"location":"changelog/#300-alpha02-january-10-2024","title":"[3.0.0-alpha02] - January 10, 2024","text":"<ul> <li>Breaking: <code>coil-gif</code>, <code>coil-network</code>, <code>coil-svg</code>, and <code>coil-video</code>'s packages have been updated so all their classes are part of <code>coil.gif</code>, <code>coil.network</code>, <code>coil.svg</code>, and <code>coil.video</code> respectively. This helps avoid class name conflicts with other artifacts.</li> <li>Breaking: <code>ImageDecoderDecoder</code> has been renamed to <code>AnimatedImageDecoder</code>.</li> <li>New: <code>coil-gif</code>, <code>coil-network</code>, <code>coil-svg</code>, and <code>coil-video</code>'s components are now automatically added to each <code>ImageLoader</code>'s <code>ComponentRegistry</code>.<ul> <li>To be clear, unlike <code>3.0.0-alpha01</code> you do not need to manually add <code>NetworkFetcher.Factory()</code> to your <code>ComponentRegistry</code>. Simply importing <code>io.coil-kt.coil3:coil-network:[version]</code> and a Ktor engine is enough to load network images.</li> <li>It's safe to also add these components to <code>ComponentRegistry</code> manually. Any manually added components take precedence over components that are added automatically.</li> <li>If preferred, this behaviour can be disabled using <code>ImageLoader.Builder.serviceLoaderEnabled(false)</code>.</li> </ul> </li> <li>New: Support <code>coil-svg</code> on all platforms. It's backed by AndroidSVG on Android and SVGDOM on non-Android platforms.</li> <li>Coil now uses Android's <code>ImageDecoder</code> API internally, which has performance benefits when decoding directly from a file, resource, or content URI.</li> <li>Fix: Multiple <code>coil3.Uri</code> parsing fixes.</li> <li>For the full list of important changes, check out the upgrade guide.</li> </ul>"},{"location":"changelog/#300-alpha01-december-30-2023","title":"[3.0.0-alpha01] - December 30, 2023","text":"<ul> <li>New: Compose Multiplatform support. Coil is now a Kotlin Multiplatform library that supports Android, JVM, iOS, macOS, and Javascript.</li> <li>Coil's Maven coordinates were updated to <code>io.coil-kt.coil3</code> and its imports were updated to <code>coil3</code>. This allows Coil 3 to run side by side with Coil 2 without binary compatibility issues. For example, <code>io.coil-kt:coil:[version]</code> is now <code>io.coil-kt.coil3:coil:[version]</code>.</li> <li>The <code>coil-base</code> and <code>coil-compose-base</code> artifacts were renamed to <code>coil-core</code> and <code>coil-compose-core</code> respectively to align with the naming conventions used by Coroutines, Ktor, and AndroidX.</li> <li>For the full list of important changes, check out the upgrade guide.</li> </ul>"},{"location":"changelog/#250-october-30-2023","title":"[2.5.0] - October 30, 2023","text":"<ul> <li>New: Add <code>MediaDataSourceFetcher.Factory</code> to support decoding <code>MediaDataSource</code> implementations in <code>coil-video</code>. (#1795)</li> <li>Add the <code>SHIFT6m</code> device to the hardware bitmap blocklist. (#1812)</li> <li>Fix: Guard against painters that return a size with one unbounded dimension. (#1826)</li> <li>Fix: Disk cache load fails after <code>304 Not Modified</code> when cached headers include non-ASCII characters. (#1839)</li> <li>Fix: <code>FakeImageEngine</code> not updating the interceptor chain's request. (#1905)</li> <li>Update compile SDK to 34.</li> <li>Update Kotlin to 1.9.10.</li> <li>Update Coroutines to 1.7.3.</li> <li>Update <code>accompanist-drawablepainter</code> to 0.32.0.</li> <li>Update <code>androidx.annotation</code> to 1.7.0.</li> <li>Update <code>androidx.compose.foundation</code> to 1.5.4.</li> <li>Update <code>androidx.core</code> to 1.12.0.</li> <li>Update <code>androidx.exifinterface:exifinterface</code> to 1.3.6.</li> <li>Update <code>androidx.lifecycle</code> to 2.6.2.</li> <li>Update <code>com.squareup.okhttp3</code> to 4.12.0.</li> <li>Update <code>com.squareup.okio</code> to 3.6.0.</li> </ul>"},{"location":"changelog/#240-may-21-2023","title":"[2.4.0] - May 21, 2023","text":"<ul> <li>Rename <code>DiskCache</code> <code>get</code>/<code>edit</code> to <code>openSnapshot</code>/<code>openEditor</code>.</li> <li>Don't automatically convert <code>ColorDrawable</code> to <code>ColorPainter</code> in <code>AsyncImagePainter</code>.</li> <li>Annotate simple <code>AsyncImage</code> overloads with <code>@NonRestartableComposable</code>.</li> <li>Fix: Call <code>Context.cacheDir</code> lazily in <code>ImageSource</code>.</li> <li>Fix: Fix publishing <code>coil-bom</code>.</li> <li>Fix: Fix always setting bitmap config to <code>ARGB_8888</code> if hardware bitmaps are disabled.</li> <li>Update Kotlin to 1.8.21.</li> <li>Update Coroutines to 1.7.1.</li> <li>Update <code>accompanist-drawablepainter</code> to 0.30.1.</li> <li>Update <code>androidx.compose.foundation</code> to 1.4.3.</li> <li>Update <code>androidx.profileinstaller:profileinstaller</code> to 1.3.1.</li> <li>Update <code>com.squareup.okhttp3</code> to 4.11.0.</li> </ul>"},{"location":"changelog/#230-march-25-2023","title":"[2.3.0] - March 25, 2023","text":"<ul> <li>New: Introduce a new <code>coil-test</code> artifact, which includes <code>FakeImageLoaderEngine</code>. This class is useful for hardcoding image loader responses to ensure consistent and synchronous (from the main thread) responses in tests. See here for more info.</li> <li>New: Add baseline profiles to <code>coil-base</code> (child module of <code>coil</code>) and <code>coil-compose-base</code> (child module of <code>coil-compose</code>).<ul> <li>This improves Coil's runtime performance and should offer better frame timings depending on how Coil is used in your app.</li> </ul> </li> <li>Fix: Fix parsing <code>file://</code> URIs with encoded data. #1601</li> <li>Fix: <code>DiskCache</code> now properly computes its maximum size if passed a directory that does not exist. #1620</li> <li>Make <code>Coil.reset</code> public API. #1506</li> <li>Enable Java default method generation. #1491</li> <li>Update Kotlin to 1.8.10.</li> <li>Update <code>accompanist-drawablepainter</code> to 0.30.0.</li> <li>Update <code>androidx.annotation</code> to 1.6.0.</li> <li>Update <code>androidx.appcompat:appcompat-resources</code> to 1.6.1.</li> <li>Update <code>androidx.compose.foundation</code> to 1.4.0.</li> <li>Update <code>androidx.core</code> to 1.9.0.</li> <li>Update <code>androidx.exifinterface:exifinterface</code> to 1.3.6.</li> <li>Update <code>androidx.lifecycle</code> to 2.6.1.</li> <li>Update <code>okio</code> to 3.3.0.</li> </ul>"},{"location":"changelog/#222-october-1-2022","title":"[2.2.2] - October 1, 2022","text":"<ul> <li>Ensure an image loader is fully initialized before registering its system callbacks. #1465</li> <li>Set the preferred bitmap config in <code>VideoFrameDecoder</code> on API 30+ to avoid banding. #1487</li> <li>Fix parsing paths containing <code>#</code> in <code>FileUriMapper</code>. #1466</li> <li>Fix reading responses with non-ascii headers from the disk cache. #1468</li> <li>Fix decoding videos inside asset subfolders. #1489</li> <li>Update <code>androidx.annotation</code> to 1.5.0.</li> </ul>"},{"location":"changelog/#221-september-8-2022","title":"[2.2.1] - September 8, 2022","text":"<ul> <li>Fix: <code>RoundedCornersTransformation</code> now properly scales the <code>input</code> bitmap.</li> <li>Remove dependency on the <code>kotlin-parcelize</code> plugin.</li> <li>Update compile SDK to 33.</li> <li>Downgrade <code>androidx.appcompat:appcompat-resources</code> to 1.4.2 to work around #1423.</li> </ul>"},{"location":"changelog/#220-august-16-2022","title":"[2.2.0] - August 16, 2022","text":"<ul> <li>New: Add <code>ImageRequest.videoFramePercent</code> to <code>coil-video</code> to support specifying the video frame as a percent of the video's duration.</li> <li>New: Add <code>ExifOrientationPolicy</code> to configure how <code>BitmapFactoryDecoder</code> treats EXIF orientation data.</li> <li>Fix: Don't throw an exception in <code>RoundedCornersTransformation</code> if passed a size with an undefined dimension.</li> <li>Fix: Read a GIF's frame delay as two unsigned bytes instead of one signed byte.</li> <li>Update Kotlin to 1.7.10.</li> <li>Update Coroutines to 1.6.4.</li> <li>Update Compose to 1.2.1.</li> <li>Update OkHttp to 4.10.0.</li> <li>Update Okio to 3.2.0.</li> <li>Update <code>accompanist-drawablepainter</code> to 0.25.1.</li> <li>Update <code>androidx.annotation</code> to 1.4.0.</li> <li>Update <code>androidx.appcompat:appcompat-resources</code> to 1.5.0.</li> <li>Update <code>androidx.core</code> to 1.8.0.</li> </ul>"},{"location":"changelog/#210-may-17-2022","title":"[2.1.0] - May 17, 2022","text":"<ul> <li>New: Support loading <code>ByteArray</code>s. (#1202)</li> <li>New: Support setting custom CSS rules for SVGs using <code>ImageRequest.Builder.css</code>. (#1210)</li> <li>Fix: Convert <code>GenericViewTarget</code>'s private methods to protected. (#1273)</li> <li>Update compile SDK to 32. (#1268)</li> </ul>"},{"location":"changelog/#200-may-10-2022","title":"[2.0.0] - May 10, 2022","text":"<p>Coil 2.0.0 is a major iteration of the library and includes breaking changes. Check out the upgrade guide for how to upgrade.</p> <ul> <li>New: Introduce <code>AsyncImage</code> in <code>coil-compose</code>. Check out the documentation for more info.</li> </ul> <pre><code>// Display an image from the network.\nAsyncImage(\n    model = \"https://example.com/image.jpg\",\n    contentDescription = null,\n)\n\n// Display an image from the network with a placeholder, circle crop, and crossfade animation.\nAsyncImage(\n    model = ImageRequest.Builder(LocalContext.current)\n        .data(\"https://example.com/image.jpg\")\n        .crossfade(true)\n        .build(),\n    placeholder = painterResource(R.drawable.placeholder),\n    contentDescription = stringResource(R.string.description),\n    contentScale = ContentScale.Crop,\n    modifier = Modifier.clip(CircleShape)\n)\n</code></pre> <ul> <li>New: Introduce a public <code>DiskCache</code> API.<ul> <li>Use <code>ImageLoader.Builder.diskCache</code> and <code>DiskCache.Builder</code> to configure the disk cache.</li> <li>You should not use OkHttp's <code>Cache</code> with Coil 2.0. See here for more info.</li> <li><code>Cache-Control</code> and other cache headers are still supported - except <code>Vary</code> headers, as the cache only checks that the URLs match. Additionally, only responses with a response code in the range [200..300) are cached.</li> <li>Existing disk caches will be cleared when upgrading to 2.0.</li> </ul> </li> <li>The minimum supported API is now 21.</li> <li><code>ImageRequest</code>'s default <code>Scale</code> is now <code>Scale.FIT</code>.<ul> <li>This was changed to make <code>ImageRequest.scale</code> consistent with other classes that have a default <code>Scale</code>.</li> <li>Requests with an <code>ImageViewTarget</code> still have their <code>Scale</code> auto-detected.</li> </ul> </li> <li>Rework the image pipeline classes:<ul> <li><code>Mapper</code>, <code>Fetcher</code>, and <code>Decoder</code> have been refactored to be more flexible.</li> <li><code>Fetcher.key</code> has been replaced with a new <code>Keyer</code> interface. <code>Keyer</code> creates the cache key from the input data.</li> <li>Add <code>ImageSource</code>, which allows <code>Decoder</code>s to read <code>File</code>s directly using Okio's file system API.</li> </ul> </li> <li>Rework the Jetpack Compose integration:<ul> <li><code>rememberImagePainter</code> and <code>ImagePainter</code> have been renamed to <code>rememberAsyncImagePainter</code> and <code>AsyncImagePainter</code> respectively.</li> <li>Deprecate <code>LocalImageLoader</code>. Check out the deprecation message for more info.</li> </ul> </li> <li>Disable generating runtime not-null assertions.<ul> <li>If you use Java, passing null as a not-null annotated argument to a function will no longer throw a <code>NullPointerException</code> immediately. Kotlin's compile-time null safety guards against this happening.</li> <li>This change allows the library's size to be smaller.</li> </ul> </li> <li><code>Size</code> is now composed of two <code>Dimension</code> values for its width and height. <code>Dimension</code> can either be a positive pixel value or <code>Dimension.Undefined</code>. See here for more info.</li> <li><code>BitmapPool</code> and <code>PoolableViewTarget</code> have been removed from the library.</li> <li><code>VideoFrameFileFetcher</code> and <code>VideoFrameUriFetcher</code> have been removed from the library. Use <code>VideoFrameDecoder</code> instead, which supports all data sources.</li> <li><code>BlurTransformation</code> and <code>GrayscaleTransformation</code> are removed from the library. If you use them, you can copy their code into your project.</li> <li>Change <code>Transition.transition</code> to be a non-suspending function as it's no longer needed to suspend the transition until it completes.</li> <li>Add support for <code>bitmapFactoryMaxParallelism</code>, which restricts the maximum number of in-progress <code>BitmapFactory</code> operations. This value is 4 by default, which improves UI performance.</li> <li>Add support for <code>interceptorDispatcher</code>, <code>fetcherDispatcher</code>, <code>decoderDispatcher</code>, and <code>transformationDispatcher</code>.</li> <li>Add <code>GenericViewTarget</code>, which handles common <code>ViewTarget</code> logic.</li> <li>Add <code>ByteBuffer</code> to the default supported data types.</li> <li><code>Disposable</code> has been refactored and exposes the underlying <code>ImageRequest</code>'s job.</li> <li>Rework the <code>MemoryCache</code> API.</li> <li><code>ImageRequest.error</code> is now set on the <code>Target</code> if <code>ImageRequest.fallback</code> is null.</li> <li><code>Transformation.key</code> is replaced with <code>Transformation.cacheKey</code>.</li> <li>Update Kotlin to 1.6.10.</li> <li>Update Compose to 1.1.1.</li> <li>Update OkHttp to 4.9.3.</li> <li>Update Okio to 3.0.0.</li> </ul> <p>Changes from <code>2.0.0-rc03</code>: - Convert <code>Dimension.Original</code> to be <code>Dimension.Undefined</code>.     - This changes the semantics of the non-pixel dimension slightly to fix some edge cases (example) in the size system. - Load images with <code>Size.ORIGINAL</code> if ContentScale is None. - Fix applying <code>ImageView.load</code> builder argument first instead of last. - Fix not combining HTTP headers if response is not modified.</p>"},{"location":"changelog/#200-rc03-april-11-2022","title":"[2.0.0-rc03] - April 11, 2022","text":"<ul> <li>Remove the <code>ScaleResolver</code> interface.</li> <li>Convert <code>Size</code> constructors to functions.</li> <li>Change <code>Dimension.Pixels</code>'s <code>toString</code> to only be its pixel value.</li> <li>Guard against a rare crash in <code>SystemCallbacks.onTrimMemory</code>.</li> <li>Update Coroutines to 1.6.1.</li> </ul>"},{"location":"changelog/#200-rc02-march-20-2022","title":"[2.0.0-rc02] - March 20, 2022","text":"<ul> <li>Revert <code>ImageRequest</code>'s default size to be the size of the current display instead of <code>Size.ORIGINAL</code>.</li> <li>Fix <code>DiskCache.Builder</code> being marked as experimental. Only <code>DiskCache</code>'s methods are experimental.</li> <li>Fix case where loading an image into an <code>ImageView</code> with one dimension as <code>WRAP_CONTENT</code> would load the image at its original size instead of fitting it into the bounded dimension.</li> <li>Remove component functions from <code>MemoryCache.Key</code>, <code>MemoryCache.Value</code>, and <code>Parameters.Entry</code>.</li> </ul>"},{"location":"changelog/#200-rc01-march-2-2022","title":"[2.0.0-rc01] - March 2, 2022","text":"<p>Significant changes since <code>1.4.0</code>:</p> <ul> <li>The minimum supported API is now 21.</li> <li>Rework the Jetpack Compose integration.<ul> <li><code>rememberImagePainter</code> has been renamed to <code>rememberAsyncImagePainter</code>.</li> <li>Add support for <code>AsyncImage</code> and <code>SubcomposeAsyncImage</code>. Check out the documentation for more info.</li> <li>Deprecate <code>LocalImageLoader</code>. Check out the deprecation message for more info.</li> </ul> </li> <li>Coil 2.0 has its own disk cache implementation and no longer relies on OkHttp for disk caching.<ul> <li>Use <code>ImageLoader.Builder.diskCache</code> and <code>DiskCache.Builder</code> to configure the disk cache.</li> <li>You should not use OkHttp's <code>Cache</code> with Coil 2.0 as the cache can be corrupted if a thread is interrupted while writing to it.</li> <li><code>Cache-Control</code> and other cache headers are still supported - except <code>Vary</code> headers, as the cache only checks that the URLs match. Additionally, only responses with a response code in the range [200..300) are cached.</li> <li>Existing disk caches will be cleared when upgrading to 2.0.</li> </ul> </li> <li><code>ImageRequest</code>'s default <code>Scale</code> is now <code>Scale.FIT</code>.<ul> <li>This was changed to make <code>ImageRequest.scale</code> consistent with other classes that have a default <code>Scale</code>.</li> <li>Requests with an <code>ImageViewTarget</code> still have their <code>Scale</code> auto-detected.</li> </ul> </li> <li><code>ImageRequest</code>'s default size is now <code>Size.ORIGINAL</code>.</li> <li>Rework the image pipeline classes:<ul> <li><code>Mapper</code>, <code>Fetcher</code>, and <code>Decoder</code> have been refactored to be more flexible.</li> <li><code>Fetcher.key</code> has been replaced with a new <code>Keyer</code> interface. <code>Keyer</code> creates the cache key from the input data.</li> <li>Add <code>ImageSource</code>, which allows <code>Decoder</code>s to read <code>File</code>s directly using Okio's file system API.</li> </ul> </li> <li>Disable generating runtime not-null assertions.<ul> <li>If you use Java, passing null as a not-null annotated parameter to a function will no longer throw a <code>NullPointerException</code> immediately. Kotlin's compile-time null safety guards against this happening.</li> <li>This change allows the library's size to be smaller.</li> </ul> </li> <li><code>Size</code> is now composed of two <code>Dimension</code> values for its width and height. <code>Dimension</code> can either be a positive pixel value or <code>Dimension.Original</code>.</li> <li><code>BitmapPool</code> and <code>PoolableViewTarget</code> have been removed from the library.</li> <li><code>VideoFrameFileFetcher</code> and <code>VideoFrameUriFetcher</code> are removed from the library. Use <code>VideoFrameDecoder</code> instead, which supports all data sources.</li> <li><code>BlurTransformation</code> and <code>GrayscaleTransformation</code> are removed from the library. If you use them, you can copy their code into your project.</li> <li>Change <code>Transition.transition</code> to be a non-suspending function as it's no longer needed to suspend the transition until it completes.</li> <li>Add support for <code>bitmapFactoryMaxParallelism</code>, which restricts the maximum number of in-progress <code>BitmapFactory</code> operations. This value is 4 by default, which improves UI performance.</li> <li>Add support for <code>interceptorDispatcher</code>, <code>fetcherDispatcher</code>, <code>decoderDispatcher</code>, and <code>transformationDispatcher</code>.</li> <li>Add <code>GenericViewTarget</code>, which handles common <code>ViewTarget</code> logic.</li> <li>Add <code>ByteBuffer</code> to the default supported data types.</li> <li><code>Disposable</code> has been refactored and exposes the underlying <code>ImageRequest</code>'s job.</li> <li>Rework the <code>MemoryCache</code> API.</li> <li><code>ImageRequest.error</code> is now set on the <code>Target</code> if <code>ImageRequest.fallback</code> is null.</li> <li><code>Transformation.key</code> is replaced with <code>Transformation.cacheKey</code>.</li> <li>Update Kotlin to 1.6.10.</li> <li>Update Compose to 1.1.1.</li> <li>Update OkHttp to 4.9.3.</li> <li>Update Okio to 3.0.0.</li> </ul> <p>Changes since <code>2.0.0-alpha09</code>:</p> <ul> <li>Remove the <code>-Xjvm-default=all</code> compiler flag.</li> <li>Fix failing to load image if multiple requests with must-revalidate/e-tag are executed concurrently.</li> <li>Fix <code>DecodeUtils.isSvg</code> returning false if there is a new line character after the <code>&lt;svg</code> tag.</li> <li>Make <code>LocalImageLoader.provides</code> deprecation message clearer.</li> <li>Update Compose to 1.1.1.</li> <li>Update <code>accompanist-drawablepainter</code> to 0.23.1.</li> </ul>"},{"location":"changelog/#200-alpha09-february-16-2022","title":"[2.0.0-alpha09] - February 16, 2022","text":"<ul> <li>Fix <code>AsyncImage</code> creating invalid constraints. (#1134)</li> <li>Add <code>ContentScale</code> argument to <code>AsyncImagePainter</code>. (#1144)<ul> <li>This should be set to the same value that's set on <code>Image</code> to ensure that the image is loaded at the correct size.</li> </ul> </li> <li>Add <code>ScaleResolver</code> to support lazily resolving the <code>Scale</code> for an <code>ImageRequest</code>. (#1134)<ul> <li><code>ImageRequest.scale</code> should be replaced by <code>ImageRequest.scaleResolver.scale()</code>.</li> </ul> </li> <li>Update Compose to 1.1.0.</li> <li>Update <code>accompanist-drawablepainter</code> to 0.23.0.</li> <li>Update <code>androidx.lifecycle</code> to 2.4.1.</li> </ul>"},{"location":"changelog/#200-alpha08-february-7-2022","title":"[2.0.0-alpha08] - February 7, 2022","text":"<ul> <li>Update <code>DiskCache</code> and <code>ImageSource</code> to use to Okio's <code>FileSystem</code> API. (#1115)</li> </ul>"},{"location":"changelog/#200-alpha07-january-30-2022","title":"[2.0.0-alpha07] - January 30, 2022","text":"<ul> <li>Significantly improve <code>AsyncImage</code> performance and split <code>AsyncImage</code> into <code>AsyncImage</code> and <code>SubcomposeAsyncImage</code>. (#1048)<ul> <li><code>SubcomposeAsyncImage</code> provides <code>loading</code>/<code>success</code>/<code>error</code>/<code>content</code> slot APIs and uses subcomposition which has worse performance.</li> <li><code>AsyncImage</code> provides <code>placeholder</code>/<code>error</code>/<code>fallback</code> arguments to overwrite the <code>Painter</code> that's drawn when loading or if the request is unsuccessful. <code>AsyncImage</code> does not use subcomposition and has much better performance than <code>SubcomposeAsyncImage</code>.</li> <li>Remove <code>AsyncImagePainter.State</code> argument from <code>SubcomposeAsyncImage.content</code>. Use <code>painter.state</code> if needed.</li> <li>Add <code>onLoading</code>/<code>onSuccess</code>/<code>onError</code> callbacks to both <code>AsyncImage</code> and <code>SubcomposeAsyncImage</code>.</li> </ul> </li> <li>Deprecate <code>LocalImageLoader</code>. (#1101)</li> <li>Add support for <code>ImageRequest.tags</code>. (#1066)</li> <li>Move <code>isGif</code>, <code>isWebP</code>, <code>isAnimatedWebP</code>, <code>isHeif</code>, and <code>isAnimatedHeif</code> in <code>DecodeUtils</code> into coil-gif. Add <code>isSvg</code> to coil-svg. (#1117)</li> <li>Convert <code>FetchResult</code> and <code>DecodeResult</code> to be non-data classes. (#1114)</li> <li>Remove unused <code>DiskCache.Builder</code> context argument. (#1099)</li> <li>Fix scaling for bitmap resources with original size. (#1072)</li> <li>Fix failing to close <code>ImageDecoder</code> in <code>ImageDecoderDecoder</code>. (#1109)</li> <li>Fix incorrect scaling when converting a drawable to a bitmap. (#1084)</li> <li>Update Compose to 1.1.0-rc03.</li> <li>Update <code>accompanist-drawablepainter</code> to 0.22.1-rc.</li> <li>Update <code>androidx.appcompat:appcompat-resources</code> to 1.4.1.</li> </ul>"},{"location":"changelog/#200-alpha06-december-24-2021","title":"[2.0.0-alpha06] - December 24, 2021","text":"<ul> <li>Add <code>ImageSource.Metadata</code> to support decoding from assets, resources, and content URIs without buffering or temporary files. (#1060)</li> <li>Delay executing the image request until <code>AsyncImage</code> has positive constraints. (#1028)</li> <li>Fix using <code>DefaultContent</code> for <code>AsyncImage</code> if <code>loading</code>, <code>success</code>, and <code>error</code> are all set. (#1026)</li> <li>Use androidx <code>LruCache</code> instead of the platform <code>LruCache</code>. (#1047)</li> <li>Update Kotlin to 1.6.10.</li> <li>Update Coroutines to 1.6.0.</li> <li>Update Compose to 1.1.0-rc01.</li> <li>Update <code>accompanist-drawablepainter</code> to 0.22.0-rc.</li> <li>Update <code>androidx.collection</code> to 1.2.0.</li> </ul>"},{"location":"changelog/#200-alpha05-november-28-2021","title":"[2.0.0-alpha05] - November 28, 2021","text":"<ul> <li>Important: Refactor <code>Size</code> to support using the image's original size for either dimension.<ul> <li><code>Size</code> is now composed of two <code>Dimension</code> values for its width and height. <code>Dimension</code> can either be a positive pixel value or <code>Dimension.Original</code>.</li> <li>This change was made to better support unbounded width/height values (e.g. <code>wrap_content</code>, <code>Constraints.Infinity</code>) when one dimension is a fixed pixel value.</li> </ul> </li> <li>Fix: Support inspection mode (preview) for <code>AsyncImage</code>.</li> <li>Fix: <code>SuccessResult.memoryCacheKey</code> should always be <code>null</code> if <code>imageLoader.memoryCache</code> is null.</li> <li>Convert <code>ImageLoader</code>, <code>SizeResolver</code>, and <code>ViewSizeResolver</code> constructor-like <code>invoke</code> functions to top level functions.</li> <li>Make <code>CrossfadeDrawable</code> start and end drawables public API.</li> <li>Mutate <code>ImageLoader</code> placeholder/error/fallback drawables.</li> <li>Add default arguments to <code>SuccessResult</code>'s constructor.</li> <li>Depend on <code>androidx.collection</code> instead of <code>androidx.collection-ktx</code>.</li> <li>Update OkHttp to 4.9.3.</li> </ul>"},{"location":"changelog/#200-alpha04-november-22-2021","title":"[2.0.0-alpha04] - November 22, 2021","text":"<ul> <li>New: Add <code>AsyncImage</code> to <code>coil-compose</code>.<ul> <li><code>AsyncImage</code> is a composable that executes an <code>ImageRequest</code> asynchronously and renders the result.</li> <li><code>AsyncImage</code> is intended to replace <code>rememberImagePainter</code> for most use cases.</li> <li>Its API is not final and may change before the final 2.0 release.</li> <li>It has a similar API to <code>Image</code> and supports the same arguments: <code>Alignment</code>, <code>ContentScale</code>, <code>alpha</code>, <code>ColorFilter</code>, and <code>FilterQuality</code>.</li> <li>It supports overwriting what's drawn for each <code>AsyncImagePainter</code> state using the <code>content</code>, <code>loading</code>, <code>success</code>, and <code>error</code> arguments.</li> <li>It fixes a number of design issues that <code>rememberImagePainter</code> has with resolving image size and scale.</li> <li>Example usages:</li> </ul> </li> </ul> <pre><code>// Only draw the image.\nAsyncImage(\n    model = \"https://example.com/image.jpg\",\n    contentDescription = null, // Avoid `null` and set this to a localized string if possible.\n)\n\n// Draw the image with a circle crop, crossfade, and overwrite the `loading` state.\nAsyncImage(\n    model = ImageRequest.Builder(LocalContext.current)\n        .data(\"https://example.com/image.jpg\")\n        .crossfade(true)\n        .build(),\n    contentDescription = null,\n    modifier = Modifier\n        .clip(CircleShape),\n    loading = {\n        CircularProgressIndicator()\n    },\n    contentScale = ContentScale.Crop\n)\n\n// Draw the image with a circle crop, crossfade, and overwrite all states.\nAsyncImage(\n    model = ImageRequest.Builder(LocalContext.current)\n        .data(\"https://example.com/image.jpg\")\n        .crossfade(true)\n        .build(),\n    contentDescription = null,\n    modifier = Modifier\n        .clip(CircleShape),\n    contentScale = ContentScale.Crop\n) { state -&gt;\n    if (state is AsyncImagePainter.State.Loading) {\n        CircularProgressIndicator()\n    } else {\n        AsyncImageContent() // Draws the image.\n    }\n}\n</code></pre> <ul> <li>Important: Rename <code>ImagePainter</code> to <code>AsyncImagePainter</code> and <code>rememberImagePainter</code> to <code>rememberAsyncImagePainter</code>.<ul> <li><code>ExecuteCallback</code> is no longer supported. To have the <code>AsyncImagePainter</code> skip waiting for <code>onDraw</code> to be called, set <code>ImageRequest.size(OriginalSize)</code> (or any size) instead.</li> <li>Add an optional <code>FilterQuality</code> argument to <code>rememberAsyncImagePainter</code>.</li> </ul> </li> <li>Use coroutines for cleanup operations in <code>DiskCache</code> and add <code>DiskCache.Builder.cleanupDispatcher</code>.</li> <li>Fix Compose preview for placeholder set using <code>ImageLoader.Builder.placeholder</code>.</li> <li>Mark <code>LocalImageLoader.current</code> with <code>@ReadOnlyComposable</code> to generate more efficient code.</li> <li>Update Compose to 1.1.0-beta03 and depend on <code>compose.foundation</code> instead of <code>compose.ui</code>.</li> <li>Update <code>androidx.appcompat-resources</code> to 1.4.0.</li> </ul>"},{"location":"changelog/#200-alpha03-november-12-2021","title":"[2.0.0-alpha03] - November 12, 2021","text":"<ul> <li>Add ability to load music thumbnails on Android 29+. (#967)</li> <li>Fix: Use <code>context.resources</code> to load resources for current package. (#968)</li> <li>Fix: <code>clear</code> -&gt; <code>dispose</code> replacement expression. (#970)</li> <li>Update Compose to 1.0.5.</li> <li>Update <code>accompanist-drawablepainter</code> to 0.20.2.</li> <li>Update Okio to 3.0.0.</li> <li>Update <code>androidx.annotation</code> to 1.3.0.</li> <li>Update <code>androidx.core</code> to 1.7.0.</li> <li>Update <code>androidx.lifecycle</code> to 2.4.0.<ul> <li>Remove dependency on <code>lifecycle-common-java8</code> as it's been merged into <code>lifecycle-common</code>.</li> </ul> </li> </ul>"},{"location":"changelog/#200-alpha02-october-24-2021","title":"[2.0.0-alpha02] - October 24, 2021","text":"<ul> <li>Add a new <code>coil-bom</code> artifact which includes a bill of materials.<ul> <li>Importing <code>coil-bom</code> allows you to depend on other Coil artifacts without specifying a version.</li> </ul> </li> <li>Fix failing to load an image when using <code>ExecuteCallback.Immediate</code>.</li> <li>Update Okio to 3.0.0-alpha.11.<ul> <li>This also resolves a compatibility issue with Okio 3.0.0-alpha.11.</li> </ul> </li> <li>Update Kotlin to 1.5.31.</li> <li>Update Compose to 1.0.4.</li> </ul>"},{"location":"changelog/#200-alpha01-october-11-2021","title":"[2.0.0-alpha01] - October 11, 2021","text":"<p>Coil 2.0.0 is the next major iteration of the library and has new features, performance improvements, API improvements, and various bug fixes. This release may be binary/source incompatible with future alpha releases until the stable release of 2.0.0.</p> <ul> <li>Important: The minimum supported API is now 21.</li> <li>Important: Enable <code>-Xjvm-default=all</code>.<ul> <li>This generates Java 8 default methods instead of using Kotlin's default interface method support. Check out this blog post for more information.</li> <li>You'll need to add <code>-Xjvm-default=all</code> or <code>-Xjvm-default=all-compatibility</code> to your build file as well. See here for how to do this.</li> </ul> </li> <li>Important: Coil now has its own disk cache implementation and no longer relies on OkHttp for disk caching.<ul> <li>This change was made to:<ul> <li>Better support thread interruption while decoding images. This improves performance when image requests are started and stopped in quick succession.</li> <li>Support exposing <code>ImageSource</code>s backed by <code>File</code>s. This avoids unnecessary copying when an Android API requires a <code>File</code> to decode (e.g. <code>MediaMetadataRetriever</code>).</li> <li>Support reading from/writing to the disk cache files directly.</li> </ul> </li> <li>Use <code>ImageLoader.Builder.diskCache</code> and <code>DiskCache.Builder</code> to configure the disk cache.</li> <li>You should not use OkHttp's <code>Cache</code> with Coil 2.0 as it can be corrupted if it's interrupted while writing to it.</li> <li><code>Cache-Control</code> and other cache headers are still supported - except <code>Vary</code> headers, as the cache only checks that the URLs match. Additionally, only responses with a response code in the range [200..300) are cached.</li> <li>Support for cache headers can be enabled or disabled using <code>ImageLoader.Builder.respectCacheHeaders</code>.</li> <li>Your existing disk cache will be cleared and rebuilt when upgrading to 2.0.</li> </ul> </li> <li>Important: <code>ImageRequest</code>'s default <code>Scale</code> is now <code>Scale.FIT</code><ul> <li>This was changed to make <code>ImageRequest.scale</code> consistent with other classes that have a default <code>Scale</code>.</li> <li>Requests with an <code>ImageViewTarget</code> still have their scale autodetected.</li> </ul> </li> <li>Significant changes to the image pipeline classes:<ul> <li><code>Mapper</code>, <code>Fetcher</code>, and <code>Decoder</code> have been refactored to be more flexible.</li> <li><code>Fetcher.key</code> has been replaced with a new <code>Keyer</code> interface. <code>Keyer</code> creates the cache key from the input data.</li> <li>Adds <code>ImageSource</code>, which allows <code>Decoder</code>s to decode <code>File</code>s directly.</li> </ul> </li> <li><code>BitmapPool</code> and <code>PoolableViewTarget</code> have been removed from the library. Bitmap pooling was removed because:<ul> <li>It's most effective on &lt;= API 23 and has become less effective with newer Android releases.</li> <li>Removing bitmap pooling allows Coil to use immutable bitmaps, which have performance benefits.</li> <li>There's runtime overhead to manage the bitmap pool.</li> <li>Bitmap pooling creates design restrictions on Coil's API as it requires tracking if a bitmap is eligible for pooling. Removing bitmap pooling allows Coil to expose the result <code>Drawable</code> in more places (e.g. <code>Listener</code>, <code>Disposable</code>). Additionally, this means Coil doesn't have to clear <code>ImageView</code>s, which has can cause issues.</li> <li>Bitmap pooling is error-prone. Allocating a new bitmap is much safer than attempting to re-use a bitmap that could still be in use.</li> </ul> </li> <li><code>MemoryCache</code> has been refactored to be more flexible.</li> <li>Disable generating runtime not-null assertions.<ul> <li>If you use Java, passing null as a not-null annotated parameter to a function will no longer throw a <code>NullPointerException</code> immediately. If you use Kotlin, there is essentially no change.</li> <li>This change allows the library's size to be smaller.</li> </ul> </li> <li><code>VideoFrameFileFetcher</code> and <code>VideoFrameUriFetcher</code> are removed from the library. Use <code>VideoFrameDecoder</code> instead, which supports all data sources.</li> <li>Adds support for <code>bitmapFactoryMaxParallelism</code>, which restricts the maximum number of in-progress <code>BitmapFactory</code> operations. This value is 4 by default, which improves UI performance.</li> <li>Adds support for <code>interceptorDispatcher</code>, <code>fetcherDispatcher</code>, <code>decoderDispatcher</code>, and <code>transformationDispatcher</code>.</li> <li><code>Disposable</code> has been refactored and exposes the underlying <code>ImageRequest</code>'s job.</li> <li>Change <code>Transition.transition</code> to be a non-suspending function as it's no longer needed to suspend the transition until it completes.</li> <li>Add <code>GenericViewTarget</code>, which handles common <code>ViewTarget</code> logic.</li> <li><code>BlurTransformation</code> and <code>GrayscaleTransformation</code> are removed from the library.<ul> <li>If you use them, you can copy their code into your project.</li> </ul> </li> <li><code>ImageRequest.error</code> is now set on the <code>Target</code> if <code>ImageRequest.fallback</code> is null.</li> <li><code>Transformation.key</code> is replaced with <code>Transformation.cacheKey</code>.</li> <li><code>ImageRequest.Listener</code> returns <code>SuccessResult</code>/<code>ErrorResult</code> in <code>onSuccess</code> and <code>onError</code> respectively.</li> <li>Add <code>ByteBuffer</code>s to the default supported data types.</li> <li>Remove <code>toString</code> implementations from several classes.</li> <li>Update OkHttp to 4.9.2.</li> <li>Update Okio to 3.0.0-alpha.10.</li> </ul>"},{"location":"changelog/#140-october-6-2021","title":"[1.4.0] - October 6, 2021","text":"<ul> <li>New: Add <code>ImageResult</code> to <code>ImagePainter.State.Success</code> and <code>ImagePainter.State.Error</code>. (#887)<ul> <li>This is a binary incompatible change to the signatures of <code>ImagePainter.State.Success</code> and <code>ImagePainter.State.Error</code>, however these APIs are marked as experimental.</li> </ul> </li> <li>Only execute <code>CrossfadeTransition</code> if <code>View.isShown</code> is <code>true</code>. Previously it would only check <code>View.isVisible</code>. (#898)</li> <li>Fix potential memory cache miss if scaling multiplier is slightly less than 1 due to a rounding issue. (#899)</li> <li>Make non-inlined <code>ComponentRegistry</code> methods public. (#925)</li> <li>Depend on <code>accompanist-drawablepainter</code> and remove Coil's custom <code>DrawablePainter</code> implementation. (#845)</li> <li>Remove use of a Java 8 method to guard against desugaring issue. (#924)</li> <li>Promote <code>ImagePainter.ExecuteCallback</code> to stable API. (#927)</li> <li>Update compileSdk to 31.</li> <li>Update Kotlin to 1.5.30.</li> <li>Update Coroutines to 1.5.2.</li> <li>Update Compose to 1.0.3.</li> </ul>"},{"location":"changelog/#132-august-4-2021","title":"[1.3.2] - August 4, 2021","text":"<ul> <li><code>coil-compose</code> now depends on <code>compose.ui</code> instead of <code>compose.foundation</code>.<ul> <li><code>compose.ui</code> is a smaller dependency as it's a subset of <code>compose.foundation</code>.</li> </ul> </li> <li>Update Jetpack Compose to 1.0.1.</li> <li>Update Kotlin to 1.5.21.</li> <li>Update Coroutines to 1.5.1.</li> <li>Update <code>androidx.exifinterface:exifinterface</code> to 1.3.3.</li> </ul>"},{"location":"changelog/#131-july-28-2021","title":"[1.3.1] - July 28, 2021","text":"<ul> <li>Update Jetpack Compose to <code>1.0.0</code>. Huge congrats to the Compose team on the stable release!</li> <li>Update <code>androidx.appcompat:appcompat-resources</code> to 1.3.1.</li> </ul>"},{"location":"changelog/#130-july-10-2021","title":"[1.3.0] - July 10, 2021","text":"<ul> <li>New: Add support for Jetpack Compose. It's based on Accompanist's Coil integration, but has a number of changes. Check out the docs for more info.</li> <li>Add <code>allowConversionToBitmap</code> to enable/disable the automatic bitmap conversion for <code>Transformation</code>s. (#775)</li> <li>Add <code>enforceMinimumFrameDelay</code> to <code>ImageDecoderDecoder</code> and <code>GifDecoder</code> to enable rewriting a GIF's frame delay if it's below a threshold. (#783)<ul> <li>This is disabled by default, but will be enabled by default in a future release.</li> </ul> </li> <li>Add support for enabling/disabling an <code>ImageLoader</code>'s internal network observer. (#741)</li> <li>Fix the density of bitmaps decoded by <code>BitmapFactoryDecoder</code>. (#776)</li> <li>Fix Licensee not finding Coil's licence url. (#774)</li> <li>Update <code>androidx.core:core-ktx</code> to 1.6.0.</li> </ul>"},{"location":"changelog/#122-june-4-2021","title":"[1.2.2] - June 4, 2021","text":"<ul> <li>Fix race condition while converting a drawable with shared state to a bitmap. (#771)</li> <li>Fix <code>ImageLoader.Builder.fallback</code> setting the <code>error</code> drawable instead of the <code>fallback</code> drawable.</li> <li>Fix incorrect data source returned by <code>ResourceUriFetcher</code>. (#770)</li> <li>Fix log check for no available file descriptors on API 26 and 27.</li> <li>Fix incorrect version check for platform vector drawable support. (#751)</li> <li>Update Kotlin (1.5.10).</li> <li>Update Coroutines (1.5.0).</li> <li>Update <code>androidx.appcompat:appcompat-resources</code> to 1.3.0.</li> <li>Update <code>androidx.core:core-ktx</code> to 1.5.0.</li> </ul>"},{"location":"changelog/#121-april-27-2021","title":"[1.2.1] - April 27, 2021","text":"<ul> <li>Fix <code>VideoFrameUriFetcher</code> attempting to handle http/https URIs. (#734</li> </ul>"},{"location":"changelog/#120-april-12-2021","title":"[1.2.0] - April 12, 2021","text":"<ul> <li>Important: Use an SVG's view bounds to calculate its aspect ratio in <code>SvgDecoder</code>. (#688)<ul> <li>Previously, <code>SvgDecoder</code> used an SVG's <code>width</code>/<code>height</code> elements to determine its aspect ratio, however this doesn't correctly follow the SVG specification.</li> <li>To revert to the old behaviour set <code>useViewBoundsAsIntrinsicSize = false</code> when constructing your <code>SvgDecoder</code>.</li> </ul> </li> <li>New: Add <code>VideoFrameDecoder</code> to support decoding video frames from any source. (#689)</li> <li>New: Support automatic SVG detection using the source's contents instead of just the MIME type. (#654)</li> <li>New: Support sharing resources using <code>ImageLoader.newBuilder()</code>. (#653)<ul> <li>Importantly, this enables sharing memory caches between <code>ImageLoader</code> instances.</li> </ul> </li> <li>New: Add support for animated image transformations using <code>AnimatedTransformation</code>. (#659)</li> <li>New: Add support for start/end callbacks for animated drawables. (#676)</li> </ul> <ul> <li>Fix parsing EXIF data for HEIF/HEIC files. (#664)</li> <li>Fix not using the <code>EmptyBitmapPool</code> implementation if bitmap pooling is disabled. (#638)<ul> <li>Without this fix bitmap pooling was still disabled properly, however it used a more heavyweight <code>BitmapPool</code> implementation.</li> </ul> </li> <li>Fix case where <code>MovieDrawable.getOpacity</code> would incorrectly return transparent. (#682)</li> <li>Guard against the default temporary directory not existing. (#683)</li> </ul> <ul> <li>Build using the JVM IR backend. (#670)</li> <li>Update Kotlin (1.4.32).</li> <li>Update Coroutines (1.4.3).</li> <li>Update OkHttp (3.12.13).</li> <li>Update <code>androidx.lifecycle:lifecycle-common-java8</code> to 2.3.1.</li> </ul>"},{"location":"changelog/#111-january-11-2021","title":"[1.1.1] - January 11, 2021","text":"<ul> <li>Fix a case where <code>ViewSizeResolver.size</code> could throw an <code>IllegalStateException</code> due to resuming a coroutine more than once.</li> <li>Fix <code>HttpFetcher</code> blocking forever if called from the main thread.<ul> <li>Requests that are forced to execute on the main thread using <code>ImageRequest.dispatcher(Dispatchers.Main.immediate)</code> will fail with a <code>NetworkOnMainThreadException</code> unless <code>ImageRequest.networkCachePolicy</code> is set to <code>CachePolicy.DISABLED</code> or <code>CachePolicy.WRITE_ONLY</code>.</li> </ul> </li> <li>Rotate video frames from <code>VideoFrameFetcher</code> if the video has rotation metadata.</li> <li>Update Kotlin (1.4.21).</li> <li>Update Coroutines (1.4.2).</li> <li>Update Okio (2.10.0).</li> <li>Update <code>androidx.exifinterface:exifinterface</code> (1.3.2).</li> </ul>"},{"location":"changelog/#110-november-24-2020","title":"[1.1.0] - November 24, 2020","text":"<ul> <li>Important: Change the <code>CENTER</code> and <code>MATRIX</code> <code>ImageView</code> scale types to resolve to <code>OriginalSize</code>. (#587)<ul> <li>This change only affects the implicit size resolution algorithm when the request's size isn't specified explicitly.</li> <li>This change was made to ensure that the visual result of an image request is consistent with <code>ImageView.setImageResource</code>/<code>ImageView.setImageURI</code>. To revert to the old behaviour set a <code>ViewSizeResolver</code> when constructing your request.</li> </ul> </li> <li>Important: Return the display size from <code>ViewSizeResolver</code> if the view's layout param is <code>WRAP_CONTENT</code>. (#562)<ul> <li>Previously, we would only return the display size if the view has been fully laid out. This change makes the typical behaviour more consistent and intuitive.</li> </ul> </li> <li>Add the ability to control alpha pre-multiplication. (#569)</li> <li>Support preferring exact intrinsic size in <code>CrossfadeDrawable</code>. (#585)</li> <li>Check for the full GIF header including version. (#564)</li> <li>Add an empty bitmap pool implementation. (#561)</li> <li>Make <code>EventListener.Factory</code> a functional interface. (#575)</li> <li>Stabilize <code>EventListener</code>. (#574)</li> <li>Add <code>String</code> overload for <code>ImageRequest.Builder.placeholderMemoryCacheKey</code>.</li> <li>Add <code>@JvmOverloads</code> to the <code>ViewSizeResolver</code> constructor.</li> <li>Fix: Mutate start/end drawables in <code>CrossfadeDrawable</code>. (#572)</li> <li>Fix: Fix GIF not playing on second load. (#577)</li> <li>Update Kotlin (1.4.20) and migrate to the <code>kotlin-parcelize</code> plugin.</li> <li>Update Coroutines (1.4.1).</li> </ul>"},{"location":"changelog/#100-october-22-2020","title":"[1.0.0] - October 22, 2020","text":"<p>Changes since <code>0.13.0</code>: - Add <code>Context.imageLoader</code> extension function. (#534) - Add <code>ImageLoader.executeBlocking</code> extension function. (#537) - Don't shutdown previous singleton image loader if replaced. (#533)</p> <p>Changes since <code>1.0.0-rc3</code>: - Fix: Guard against missing/invalid ActivityManager. (#541) - Fix: Allow OkHttp to cache unsuccessful responses. (#551) - Update Kotlin to 1.4.10. - Update Okio to 2.9.0. - Update <code>androidx.exifinterface:exifinterface</code> to 1.3.1.</p>"},{"location":"changelog/#100-rc3-september-21-2020","title":"[1.0.0-rc3] - September 21, 2020","text":"<ul> <li>Revert using the <code>-Xjvm-default=all</code> compiler flag due to instability.<ul> <li>This is a source compatible, but binary incompatible change from previous release candidate versions.</li> </ul> </li> <li>Add <code>Context.imageLoader</code> extension function. (#534)</li> <li>Add <code>ImageLoader.executeBlocking</code> extension function. (#537)</li> <li>Don't shutdown previous singleton image loader if replaced. (#533)</li> <li>Update AndroidX dependencies:<ul> <li><code>androidx.exifinterface:exifinterface</code> -&gt; 1.3.0</li> </ul> </li> </ul>"},{"location":"changelog/#100-rc2-september-3-2020","title":"[1.0.0-rc2] - September 3, 2020","text":"<ul> <li>This release requires Kotlin 1.4.0 or above.</li> <li>All the changes present in 0.13.0.</li> <li>Depend on the base Kotlin <code>stdlib</code> instead of <code>stdlib-jdk8</code>.</li> </ul>"},{"location":"changelog/#0130-september-3-2020","title":"[0.13.0] - September 3, 2020","text":"<ul> <li>Important: Launch the Interceptor chain on the main thread by default. (#513)<ul> <li>This largely restores the behaviour from <code>0.11.0</code> and below where the memory cache would be checked synchronously on the main thread.</li> <li>To revert to using the same behaviour as <code>0.12.0</code> where the memory cache is checked on <code>ImageRequest.dispatcher</code>, set <code>ImageLoader.Builder.launchInterceptorChainOnMainThread(false)</code>.</li> <li>See <code>launchInterceptorChainOnMainThread</code> for more information.</li> </ul> </li> </ul> <ul> <li>Fix: Fix potential memory leak if request is started on a <code>ViewTarget</code> in a detached fragment. (#518)</li> <li>Fix: Use <code>ImageRequest.context</code> to load resource URIs. (#517)</li> <li>Fix: Fix race condition that could cause subsequent requests to not be saved to the disk cache. (#510)</li> <li>Fix: Use <code>blockCountLong</code> and <code>blockSizeLong</code> on API 18.</li> </ul> <ul> <li>Make <code>ImageLoaderFactory</code> a fun interface.</li> <li>Add <code>ImageLoader.Builder.addLastModifiedToFileCacheKey</code> which allows you to enable/disable adding the last modified timestamp to the memory cache key for an image loaded from a <code>File</code>.</li> </ul> <ul> <li>Update Kotlin to 1.4.0.</li> <li>Update Coroutines to 1.3.9.</li> <li>Update Okio to 2.8.0.</li> </ul>"},{"location":"changelog/#100-rc1-august-18-2020","title":"[1.0.0-rc1] - August 18, 2020","text":"<ul> <li>This release requires Kotlin 1.4.0 or above.</li> <li>Update Kotlin to 1.4.0 and enable <code>-Xjvm-default=all</code>.<ul> <li>See here for how to enable <code>-Xjvm-default=all</code> in your build file.</li> <li>This generates Java 8 default methods for default Kotlin interface methods.</li> </ul> </li> <li>Remove all existing deprecated methods in 0.12.0.</li> <li>Update Coroutines to 1.3.9.</li> </ul>"},{"location":"changelog/#0120-august-18-2020","title":"[0.12.0] - August 18, 2020","text":"<ul> <li>Breaking: <code>LoadRequest</code> and <code>GetRequest</code> have been replaced with <code>ImageRequest</code>:<ul> <li><code>ImageLoader.execute(LoadRequest)</code> -&gt; <code>ImageLoader.enqueue(ImageRequest)</code></li> <li><code>ImageLoader.execute(GetRequest)</code> -&gt; <code>ImageLoader.execute(ImageRequest)</code></li> <li><code>ImageRequest</code> implements <code>equals</code>/<code>hashCode</code>.</li> </ul> </li> <li>Breaking: A number of classes were renamed and/or changed package:<ul> <li><code>coil.request.RequestResult</code> -&gt; <code>coil.request.ImageResult</code></li> <li><code>coil.request.RequestDisposable</code> -&gt; <code>coil.request.Disposable</code></li> <li><code>coil.bitmappool.BitmapPool</code> -&gt; <code>coil.bitmap.BitmapPool</code></li> <li><code>coil.DefaultRequestOptions</code> -&gt; <code>coil.request.DefaultRequestOptions</code></li> </ul> </li> <li>Breaking: <code>SparseIntArraySet</code> has been removed from the public API.</li> <li>Breaking: <code>TransitionTarget</code> no longer implements <code>ViewTarget</code>.</li> <li>Breaking: <code>ImageRequest.Listener.onSuccess</code>'s signature has changed to return an <code>ImageResult.Metadata</code> instead of just a <code>DataSource</code>.</li> <li>Breaking: Remove support for <code>LoadRequest.aliasKeys</code>. This API is better handled with direct read/write access to the memory cache.</li> </ul> <ul> <li>Important: Values in the memory cache are no longer resolved synchronously (if called from the main thread).<ul> <li>This change was also necessary to support executing <code>Interceptor</code>s on a background dispatcher.</li> <li>This change also moves more work off the main thread, improving performance.</li> </ul> </li> <li>Important: <code>Mappers</code> are now executed on a background dispatcher. As a side effect, automatic bitmap sampling is no longer automatically supported. To achieve the same effect, use the <code>MemoryCache.Key</code> of a previous request as the <code>placeholderMemoryCacheKey</code> of the subsequent request. See here for an example.<ul> <li>The <code>placeholderMemoryCacheKey</code> API offers more freedom as you can \"link\" two image requests with different data (e.g. different URLs for small/large images).</li> </ul> </li> <li>Important: Coil's <code>ImageView</code> extension functions have been moved from the <code>coil.api</code> package to the <code>coil</code> package.<ul> <li>Use find + replace to refactor <code>import coil.api.load</code> -&gt; <code>import coil.load</code>. Unfortunately, it's not possible to use Kotlin's <code>ReplaceWith</code> functionality to replace imports.</li> </ul> </li> <li>Important: Use standard crossfade if drawables are not the same image.</li> <li>Important: Prefer immutable bitmaps on API 24+.</li> <li>Important: <code>MeasuredMapper</code> has been deprecated in favour of the new <code>Interceptor</code> interface. See here for an example of how to convert a <code>MeasuredMapper</code> into an <code>Interceptor</code>.<ul> <li><code>Interceptor</code> is a much less restrictive API that allows for a wider range of custom logic.</li> </ul> </li> <li>Important: <code>ImageRequest.data</code> is now not null. If you create an <code>ImageRequest</code> without setting its data it will return <code>NullRequestData</code> as its data.</li> </ul> <ul> <li>New: Add support for direct read/write access to an <code>ImageLoader</code>'s <code>MemoryCache</code>. See the docs for more information.</li> <li>New: Add support for <code>Interceptor</code>s. See the docs for more information. Coil's <code>Interceptor</code> design is heavily inspired by OkHttp's!</li> <li>New: Add the ability to enable/disable bitmap pooling using <code>ImageLoader.Builder.bitmapPoolingEnabled</code>.<ul> <li>Bitmap pooling is most effective on API 23 and below, but may still be benificial on API 24 and up (by eagerly calling <code>Bitmap.recycle</code>).</li> </ul> </li> <li>New: Support thread interruption while decoding.</li> </ul> <ul> <li>Fix parsing multiple segments in content-type header.</li> <li>Rework bitmap reference counting to be more robust.</li> <li>Fix WebP decoding on API &lt; 19 devices.</li> <li>Expose FetchResult and DecodeResult in the EventListener API.</li> </ul> <ul> <li>Compile with SDK 30.</li> <li>Update Coroutines to 1.3.8.</li> <li>Update OkHttp to 3.12.12.</li> <li>Update Okio to 2.7.0.</li> <li>Update AndroidX dependencies:<ul> <li><code>androidx.appcompat:appcompat-resources</code> -&gt; 1.2.0</li> <li><code>androidx.core:core-ktx</code> -&gt; 1.3.1</li> </ul> </li> </ul>"},{"location":"changelog/#0110-may-14-2020","title":"[0.11.0] - May 14, 2020","text":"<ul> <li>Breaking: This version removes all existing deprecated functions.<ul> <li>This enables removing Coil's <code>ContentProvider</code> so it doesn't run any code at app startup.</li> </ul> </li> <li>Breaking: Convert <code>SparseIntArraySet.size</code> to a val. (#380)</li> <li>Breaking: Move <code>Parameters.count()</code> to an extension function. (#403)</li> <li>Breaking: Make <code>BitmapPool.maxSize</code> an Int. (#404)</li> </ul> <ul> <li>Important: Make <code>ImageLoader.shutdown()</code> optional (similar to <code>OkHttpClient</code>). (#385)</li> </ul> <ul> <li>Fix: Fix AGP 4.1 compatibility. (#386)</li> <li>Fix: Fix measuring GONE views. (#397)</li> </ul> <ul> <li>Reduce the default memory cache size to 20%. (#390)<ul> <li>To restore the existing behaviour set <code>ImageLoaderBuilder.availableMemoryPercentage(0.25)</code> when creating your <code>ImageLoader</code>.</li> </ul> </li> <li>Update Coroutines to 1.3.6.</li> <li>Update OkHttp to 3.12.11.</li> </ul>"},{"location":"changelog/#0101-april-26-2020","title":"[0.10.1] - April 26, 2020","text":"<ul> <li>Fix OOM when decoding large PNGs on API 23 and below. (#372).<ul> <li>This disables decoding EXIF orientation for PNG files. PNG EXIF orientation is very rarely used and reading PNG EXIF data (even if it's empty) requires buffering the entire file into memory, which is bad for performance.</li> </ul> </li> <li>Minor Java compatibility improvements to <code>SparseIntArraySet</code>.</li> </ul> <ul> <li>Update Okio to 2.6.0.</li> </ul>"},{"location":"changelog/#0100-april-20-2020","title":"[0.10.0] - April 20, 2020","text":""},{"location":"changelog/#highlights","title":"Highlights","text":"<ul> <li> <p>This version deprecates most of the DSL API in favour of using the builders directly. Here's what the change looks like:</p> <pre><code>// 0.9.5 (old)\nval imageLoader = ImageLoader(context) {\n    bitmapPoolPercentage(0.5)\n    crossfade(true)\n}\n\nval disposable = imageLoader.load(context, \"https://example.com/image.jpg\") {\n    target(imageView)\n}\n\nval drawable = imageLoader.get(\"https://example.com/image.jpg\") {\n    size(512, 512)\n}\n\n// 0.10.0 (new)\nval imageLoader = ImageLoader.Builder(context)\n    .bitmapPoolPercentage(0.5)\n    .crossfade(true)\n    .build()\n\nval request = LoadRequest.Builder(context)\n    .data(\"https://example.com/image.jpg\")\n    .target(imageView)\n    .build()\nval disposable = imageLoader.execute(request)\n\nval request = GetRequest.Builder(context)\n    .data(\"https://example.com/image.jpg\")\n    .size(512, 512)\n    .build()\nval drawable = imageLoader.execute(request).drawable\n</code></pre> <ul> <li>If you're using the <code>io.coil-kt:coil</code> artifact, you can call <code>Coil.execute(request)</code> to execute the request with the singleton <code>ImageLoader</code>.</li> </ul> </li> <li> <p><code>ImageLoader</code>s now have a weak reference memory cache that tracks weak references to images once they're evicted from the strong reference memory cache.</p> <ul> <li>This means an image will always be returned from an <code>ImageLoader</code>'s memory cache if there's still a strong reference to it.</li> <li>Generally, this should make the memory cache much more predictable and increase its hit rate.</li> <li>This behaviour can be enabled/disabled with <code>ImageLoaderBuilder.trackWeakReferences</code>.</li> </ul> </li> <li> <p>Add a new artifact, <code>io.coil-kt:coil-video</code>, to decode specific frames from a video file. Read more here.</p> </li> <li> <p>Add a new EventListener API for tracking metrics.</p> </li> <li> <p>Add ImageLoaderFactory which can be implemented by your <code>Application</code> to simplify singleton initialization.</p> </li> </ul>"},{"location":"changelog/#full-release-notes","title":"Full Release Notes","text":"<ul> <li>Important: Deprecate DSL syntax in favour of builder syntax. (#267)</li> <li>Important: Deprecate <code>Coil</code> and <code>ImageLoader</code> extension functions. (#322)</li> <li>Breaking: Return sealed <code>RequestResult</code> type from <code>ImageLoader.execute(GetRequest)</code>. (#349)</li> <li>Breaking: Rename <code>ExperimentalCoil</code> to <code>ExperimentalCoilApi</code>. Migrate from <code>@Experimental</code> to <code>@RequiresOptIn</code>. (#306)</li> <li>Breaking: Replace <code>CoilLogger</code> with <code>Logger</code> interface. (#316)</li> <li>Breaking: Rename destWidth/destHeight to dstWidth/dstHeight. (#275)</li> <li>Breaking: Re-arrange <code>MovieDrawable</code>'s constructor params. (#272)</li> <li>Breaking: <code>Request.Listener</code>'s methods now receive the full <code>Request</code> object instead of just its data.</li> <li>Breaking: <code>GetRequestBuilder</code> now requires a <code>Context</code> in its constructor.</li> <li>Breaking: Several properties on <code>Request</code> are now nullable.</li> <li>Behaviour change: Include parameter values in the cache key by default. (#319)</li> <li>Behaviour change: Slightly adjust <code>Request.Listener.onStart()</code> timing to be called immediately after <code>Target.onStart()</code>. (#348)</li> </ul> <ul> <li>New: Add <code>WeakMemoryCache</code> implementation. (#295)</li> <li>New: Add <code>coil-video</code> to support decoding video frames. (#122)</li> <li>New: Introduce <code>EventListener</code>. (#314)</li> <li>New: Introduce <code>ImageLoaderFactory</code>. (#311)</li> <li>New: Support animated HEIF image sequences on Android 11. (#297)</li> <li>New: Improve Java compatibility. (#262)</li> <li>New: Support setting a default <code>CachePolicy</code>. (#307)</li> <li>New: Support setting a default <code>Bitmap.Config</code>. (#342)</li> <li>New: Add <code>ImageLoader.invalidate(key)</code> to clear a single memory cache item (#55)</li> <li>New: Add debug logs to explain why a cached image is not reused. (#346)</li> <li>New: Support <code>error</code> and <code>fallback</code> drawables for get requests.</li> </ul> <ul> <li>Fix: Fix memory cache miss when Transformation reduces input bitmap's size. (#357)</li> <li>Fix: Ensure radius is below RenderScript max in BlurTransformation. (#291)</li> <li>Fix: Fix decoding high colour depth images. (#358)</li> <li>Fix: Disable <code>ImageDecoderDecoder</code> crash work-around on Android 11 and above. (#298)</li> <li>Fix: Fix failing to read EXIF data on pre-API 23. (#331)</li> <li>Fix: Fix incompatibility with Android R SDK. (#337)</li> <li>Fix: Only enable inexact size if <code>ImageView</code> has a matching <code>SizeResolver</code>. (#344)</li> <li>Fix: Allow cached images to be at most one pixel off requested size. (#360)</li> <li>Fix: Skip crossfade transition if view is not visible. (#361)</li> </ul> <ul> <li>Deprecate <code>CoilContentProvider</code>. (#293)</li> <li>Annotate several <code>ImageLoader</code> methods with <code>@MainThread</code>.</li> <li>Avoid creating a <code>LifecycleCoroutineDispatcher</code> if the lifecycle is currently started. (#356)</li> <li>Use full package name for <code>OriginalSize.toString()</code>.</li> <li>Preallocate when decoding software bitmap. (#354)</li> </ul> <ul> <li>Update Kotlin to 1.3.72.</li> <li>Update Coroutines to 1.3.5.</li> <li>Update OkHttp to 3.12.10.</li> <li>Update Okio to 2.5.0.</li> <li>Update AndroidX dependencies:<ul> <li><code>androidx.exifinterface:exifinterface</code> -&gt; 1.2.0</li> </ul> </li> </ul>"},{"location":"changelog/#095-february-6-2020","title":"[0.9.5] - February 6, 2020","text":"<ul> <li>Fix: Ensure a view is attached before checking if it is hardware accelerated. This fixes a case where requesting a hardware bitmap could miss the memory cache.</li> </ul> <ul> <li>Update AndroidX dependencies:<ul> <li><code>androidx.core:core-ktx</code> -&gt; 1.2.0</li> </ul> </li> </ul>"},{"location":"changelog/#094-february-3-2020","title":"[0.9.4] - February 3, 2020","text":"<ul> <li>Fix: Respect aspect ratio when downsampling in ImageDecoderDecoder. Thanks @zhanghai.</li> </ul> <ul> <li>Previously bitmaps would be returned from the memory cache as long as their config was greater than or equal to the config specified in the request. For example, if you requested an <code>ARGB_8888</code> bitmap, it would be possible to have a <code>RGBA_F16</code> bitmap returned to you from the memory cache. Now, the cached config and the requested config must be equal.</li> <li>Make <code>scale</code> and <code>durationMillis</code> public in <code>CrossfadeDrawable</code> and <code>CrossfadeTransition</code>.</li> </ul>"},{"location":"changelog/#093-february-1-2020","title":"[0.9.3] - February 1, 2020","text":"<ul> <li>Fix: Translate child drawable inside <code>ScaleDrawable</code> to ensure it is centered.</li> <li>Fix: Fix case where GIFs and SVGs would not fill bounds completely.</li> </ul> <ul> <li>Defer calling <code>HttpUrl.get()</code> to background thread.</li> <li>Improve BitmapFactory null bitmap error message.</li> <li>Add 3 devices to hardware bitmap blacklist. (#264)</li> </ul> <ul> <li>Update AndroidX dependencies:<ul> <li><code>androidx.lifecycle:lifecycle-common-java8</code> -&gt; 2.2.0</li> </ul> </li> </ul>"},{"location":"changelog/#092-january-19-2020","title":"[0.9.2] - January 19, 2020","text":"<ul> <li>Fix: Fix decoding GIFs on pre-API 19. Thanks @mario.</li> <li>Fix: Fix rasterized vector drawables not being marked as sampled.</li> <li>Fix: Throw exception if Movie dimensions are &lt;= 0.</li> <li>Fix: Fix CrossfadeTransition not being resumed for a memory cache event.</li> <li>Fix: Prevent returning hardware bitmaps to all target methods if disallowed.</li> <li>Fix: Fix MovieDrawable not positioning itself in the center of its bounds.</li> </ul> <ul> <li>Remove automatic scaling from CrossfadeDrawable.</li> <li>Make <code>BitmapPool.trimMemory</code> public.</li> <li>Wrap AnimatedImageDrawable in a ScaleDrawable to ensure it fills its bounds.</li> <li>Add @JvmOverloads to RequestBuilder.setParameter.</li> <li>Set an SVG's view box to its size if the view box is not set.</li> <li>Pass state and level changes to CrossfadeDrawable children.</li> </ul> <ul> <li>Update OkHttp to 3.12.8.</li> </ul>"},{"location":"changelog/#091-december-30-2019","title":"[0.9.1] - December 30, 2019","text":"<ul> <li>Fix: Fix crash when calling <code>LoadRequestBuilder.crossfade(false)</code>.</li> </ul>"},{"location":"changelog/#090-december-30-2019","title":"[0.9.0] - December 30, 2019","text":"<ul> <li>Breaking: <code>Transformation.transform</code> now includes a <code>Size</code> parameter. This is to support transformations that change the size of the output <code>Bitmap</code> based on the size of the <code>Target</code>. Requests with transformations are now also exempt from image sampling.</li> <li>Breaking: <code>Transformation</code>s are now applied to any type of <code>Drawable</code>. Before, <code>Transformation</code>s would be skipped if the input <code>Drawable</code> was not a <code>BitmapDrawable</code>. Now, <code>Drawable</code>s are rendered to a <code>Bitmap</code> before applying the <code>Transformation</code>s.</li> <li>Breaking: Passing <code>null</code> data to <code>ImageLoader.load</code> is now treated as an error and calls <code>Target.onError</code> and <code>Request.Listener.onError</code> with a <code>NullRequestDataException</code>. This change was made to support setting a <code>fallback</code> drawable if data is <code>null</code>. Previously the request was silently ignored.</li> <li>Breaking: <code>RequestDisposable.isDisposed</code> is now a <code>val</code>.</li> </ul> <ul> <li>New: Support for custom transitions. See here for more info. Transitions are marked as experimental as the API is incubating.</li> <li>New: Add <code>RequestDisposable.await</code> to support suspending while a <code>LoadRequest</code> is in progress.</li> <li>New: Support setting a <code>fallback</code> drawable when request data is null.</li> <li>New: Add <code>Precision</code>. This makes the size of the output <code>Drawable</code> exact while enabling scaling optimizations for targets that support scaling (e.g. <code>ImageViewTarget</code>). See its documentation for more information.</li> <li>New: Add <code>RequestBuilder.aliasKeys</code> to support matching multiple cache keys.</li> </ul> <ul> <li>Fix: Make RequestDisposable thread safe.</li> <li>Fix: <code>RoundedCornersTransformation</code> now crops to the size of the target then rounds the corners.</li> <li>Fix: <code>CircleCropTransformation</code> now crops from the center.</li> <li>Fix: Add several devices to the hardware bitmap blacklist.</li> <li>Fix: Preserve aspect ratio when converting a Drawable to a Bitmap.</li> <li>Fix: Fix possible memory cache miss with <code>Scale.FIT</code>.</li> <li>Fix: Ensure Parameters iteration order is deterministic.</li> <li>Fix: Defensive copy when creating Parameters and ComponentRegistry.</li> <li>Fix: Ensure RealBitmapPool's maxSize &gt;= 0.</li> <li>Fix: Show the start drawable if CrossfadeDrawable is not animating or done.</li> <li>Fix: Adjust CrossfadeDrawable to account for children with undefined intrinsic size.</li> <li>Fix: Fix <code>MovieDrawable</code> not scaling properly.</li> </ul> <ul> <li>Update Kotlin to 1.3.61.</li> <li>Update Kotlin Coroutines to 1.3.3.</li> <li>Update Okio to 2.4.3.</li> <li>Update AndroidX dependencies:<ul> <li><code>androidx.exifinterface:exifinterface</code> -&gt; 1.1.0</li> </ul> </li> </ul>"},{"location":"changelog/#080-october-22-2019","title":"[0.8.0] - October 22, 2019","text":"<ul> <li>Breaking: <code>SvgDrawable</code> has been removed. Instead, SVGs are now prerendered to <code>BitmapDrawable</code>s by <code>SvgDecoder</code>. This makes SVGs significantly less expensive to render on the main thread. Also <code>SvgDecoder</code> now requires a <code>Context</code> in its constructor.</li> <li>Breaking: <code>SparseIntArraySet</code> extension functions have moved to the <code>coil.extension</code> package.</li> </ul> <ul> <li>New: Support setting per-request network headers. See here for more info.</li> <li>New: Add new <code>Parameters</code> API to support passing custom data through the image pipeline.</li> <li>New: Support individual corner radii in RoundedCornersTransformation. Thanks @khatv911.</li> <li>New: Add <code>ImageView.clear()</code> to support proactively freeing resources.</li> <li>New: Support loading resources from other packages.</li> <li>New: Add <code>subtractPadding</code> attribute to ViewSizeResolver to enable/disable subtracting a view's padding when measuring.</li> <li>New: Improve HttpUrlFetcher MIME type detection.</li> <li>New: Add Animatable2Compat support to MovieDrawable and CrossfadeDrawable.</li> <li>New: Add <code>RequestBuilder&lt;*&gt;.repeatCount</code> to set the repeat count for a GIF.</li> <li>New: Add BitmapPool creation to the public API.</li> <li>New: Annotate Request.Listener methods with <code>@MainThread</code>.</li> </ul> <ul> <li>Fix: Make CoilContentProvider visible for testing.</li> <li>Fix: Include night mode in the resource cache key.</li> <li>Fix: Work around ImageDecoder native crash by temporarily writing the source to disk.</li> <li>Fix: Correctly handle contact display photo uris.</li> <li>Fix: Pass tint to CrossfadeDrawable's children.</li> <li>Fix: Fix several instances of not closing sources.</li> <li>Fix: Add a blacklist of devices with broken/incomplete hardware bitmap implementations.</li> </ul> <ul> <li>Compile against SDK 29.</li> <li>Update Kotlin Coroutines to 1.3.2.</li> <li>Update OkHttp to 3.12.6.</li> <li>Update Okio to 2.4.1.</li> <li>Change <code>appcompat-resources</code> from <code>compileOnly</code> to <code>implementation</code> for <code>coil-base</code>.</li> </ul>"},{"location":"changelog/#070-september-8-2019","title":"[0.7.0] - September 8, 2019","text":"<ul> <li>Breaking: <code>ImageLoaderBuilder.okHttpClient(OkHttpClient.Builder.() -&gt; Unit)</code> is now <code>ImageLoaderBuilder.okHttpClient(() -&gt; OkHttpClient)</code>. The initializer is also now called lazily on a background thread. If you set a custom <code>OkHttpClient</code> you must set <code>OkHttpClient.cache</code> to enable disk caching. If you don't set a custom <code>OkHttpClient</code>, Coil will create the default <code>OkHttpClient</code> which has disk caching enabled. The default Coil cache can be created using <code>CoilUtils.createDefaultCache(context)</code>. e.g.:</li> </ul> <pre><code>val imageLoader = ImageLoader(context) {\n    okHttpClient {\n        OkHttpClient.Builder()\n            .cache(CoilUtils.createDefaultCache(context))\n            .build()\n    }\n}\n</code></pre> <ul> <li>Breaking: <code>Fetcher.key</code> no longer has a default implementation.</li> <li>Breaking: Previously, only the first applicable <code>Mapper</code> would be called. Now, all applicable <code>Mapper</code>s will be called. No API changes.</li> <li>Breaking: Minor named parameter renaming: <code>url</code> -&gt; <code>uri</code>, <code>factory</code> -&gt; <code>initializer</code>.</li> </ul> <ul> <li>New: <code>coil-svg</code> artifact, which has an <code>SvgDecoder</code> that supports automatically decoding SVGs. Powered by AndroidSVG. Thanks @rharter.</li> <li>New: <code>load(String)</code> and <code>get(String)</code> now accept any of the supported Uri schemes. e.g. You can now do <code>imageView.load(\"file:///path/to/file.jpg\")</code>.</li> <li>New: Refactor ImageLoader to use <code>Call.Factory</code> instead of <code>OkHttpClient</code>. This allows lazy initialization of the networking resources using <code>ImageLoaderBuilder.okHttpClient { OkHttpClient() }</code>. Thanks @ZacSweers.</li> <li>New: <code>RequestBuilder.decoder</code> to explicitly set the decoder for a request.</li> <li>New: <code>ImageLoaderBuilder.allowHardware</code> to enable/disable hardware bitmaps by default for an ImageLoader.</li> <li>New: Support software rendering in ImageDecoderDecoder.</li> </ul> <ul> <li>Fix: Multiple bugs with loading vector drawables.</li> <li>Fix: Support WRAP_CONTENT View dimensions.</li> <li>Fix: Support parsing EXIF data longer than 8192 bytes.</li> <li>Fix: Don't stretch drawables with different aspect ratios when crossfading.</li> <li>Fix: Guard against network observer failing to register due to exception.</li> <li>Fix: Fix divide by zero error in MovieDrawable. Thanks @R12rus.</li> <li>Fix: Support nested Android asset files. Thanks @JaCzekanski.</li> <li>Fix: Guard against running out of file descriptors on Android O and O_MR1.</li> <li>Fix: Don't crash when disabling memory cache. Thanks @hansenji.</li> <li>Fix: Ensure Target.cancel is always called from the main thread.</li> </ul> <ul> <li>Update Kotlin to 1.3.50.</li> <li>Update Kotlin Coroutines to 1.3.0.</li> <li>Update OkHttp to 3.12.4.</li> <li>Update Okio to 2.4.0.</li> <li>Update AndroidX dependencies to the latest stable versions:<ul> <li><code>androidx.appcompat:appcompat</code> -&gt; 1.1.0</li> <li><code>androidx.core:core-ktx</code> -&gt; 1.1.0</li> <li><code>androidx.lifecycle:lifecycle-common-java8</code> -&gt; 2.1.0</li> </ul> </li> <li>Replace <code>appcompat</code> with <code>appcompat-resources</code> as an optional <code>compileOnly</code> dependency. <code>appcompat-resources</code> is a much smaller artifact.</li> </ul>"},{"location":"changelog/#061-august-16-2019","title":"[0.6.1] - August 16, 2019","text":"<ul> <li>New: Add <code>transformations(List&lt;Transformation&gt;)</code> to RequestBuilder.</li> <li>Fix: Add the last modified date to the cache key for file uris.</li> <li>Fix: Ensure View dimensions are evaluated to at least 1px.</li> <li>Fix: Clear MovieDrawable's canvas between frames.</li> <li>Fix: Open assets correctly.</li> </ul>"},{"location":"changelog/#060-august-12-2019","title":"[0.6.0] - August 12, 2019","text":"<ul> <li>Initial release.</li> </ul>"},{"location":"code_of_conduct/","title":"Code of Conduct","text":""},{"location":"code_of_conduct/#our-pledge","title":"Our Pledge","text":"<p>In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.</p>"},{"location":"code_of_conduct/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to creating a positive environment include:</p> <ul> <li>Using welcoming and inclusive language</li> <li>Being respectful of differing viewpoints and experiences</li> <li>Gracefully accepting constructive criticism</li> <li>Focusing on what is best for the community</li> <li>Showing empathy towards other community members</li> </ul> <p>Examples of unacceptable behavior by participants include:</p> <ul> <li>The use of sexualized language or imagery and unwelcome sexual attention or   advances</li> <li>Trolling, insulting/derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or electronic   address, without explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a   professional setting</li> </ul>"},{"location":"code_of_conduct/#our-responsibilities","title":"Our Responsibilities","text":"<p>Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior.</p> <p>Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.</p>"},{"location":"code_of_conduct/#scope","title":"Scope","text":"<p>This Code of Conduct applies within all project spaces, and it also applies when an individual is representing the project or its community in public spaces. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.</p>"},{"location":"code_of_conduct/#enforcement","title":"Enforcement","text":"<p>Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at colin at colinwhite.me. All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately.</p> <p>Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership.</p>"},{"location":"code_of_conduct/#attribution","title":"Attribution","text":"<p>This Code of Conduct is adapted from the Contributor Covenant, version 1.4, available at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html</p> <p>For answers to common questions about this code of conduct, see https://www.contributor-covenant.org/faq</p>"},{"location":"compose/","title":"Compose","text":"<p>To add support for Compose UI, import the extension library:</p> <pre><code>implementation(\"io.coil-kt.coil3:coil-compose:3.4.0\")\n</code></pre> <p>Then use the <code>AsyncImage</code> composable to load and display an image:</p> <pre><code>AsyncImage(\n    model = \"https://example.com/image.jpg\",\n    contentDescription = null,\n)\n</code></pre> <p><code>model</code> can either be the <code>ImageRequest.data</code> value - or the <code>ImageRequest</code> itself. <code>contentDescription</code> sets the text used by accessibility services to describe what this image represents.</p>"},{"location":"compose/#asyncimage","title":"AsyncImage","text":"<p><code>AsyncImage</code> is a composable that executes an image request asynchronously and renders the result. It supports the same arguments as the standard <code>Image</code> composable and additionally, it supports setting <code>placeholder</code>/<code>error</code>/<code>fallback</code> painters and <code>onLoading</code>/<code>onSuccess</code>/<code>onError</code> callbacks. Here's an example that loads an image with a circle crop, crossfade, and sets a placeholder:</p> <pre><code>AsyncImage(\n    model = ImageRequest.Builder(LocalContext.current)\n        .data(\"https://example.com/image.jpg\")\n        .crossfade(true)\n        .build(),\n    placeholder = painterResource(R.drawable.placeholder),\n    contentDescription = stringResource(R.string.description),\n    contentScale = ContentScale.Crop,\n    modifier = Modifier.clip(CircleShape),\n)\n</code></pre> <p>When to use this function:</p> <p>Prefer using <code>AsyncImage</code> in most cases. It correctly determines the size your image should be loaded at based on the constraints of the composable and the provided <code>ContentScale</code>.</p>"},{"location":"compose/#rememberasyncimagepainter","title":"rememberAsyncImagePainter","text":"<p>Internally, <code>AsyncImage</code> and <code>SubcomposeAsyncImage</code> use <code>rememberAsyncImagePainter</code> to load the <code>model</code>. If you need a <code>Painter</code> and not a composable, you can load the image using <code>rememberAsyncImagePainter</code>:</p> <pre><code>val painter = rememberAsyncImagePainter(\"https://example.com/image.jpg\")\n</code></pre> <p><code>rememberAsyncImagePainter</code> is more flexible than <code>AsyncImage</code> and <code>SubcomposeAsyncImage</code>, but has a couple drawbacks (see below).</p> <p>When to use this function:</p> <p>Useful if you need a <code>Painter</code> instead of a composable - or if you need to observe the <code>AsyncImagePainter.state</code> and draw a different composable based on it - or if you need to manually restart the image request using <code>AsyncImagePainter.restart</code>.</p> <p>The main drawback of this function is it does not detect the size your image is loaded at on screen and always loads the image with its original dimensions. You can pass a custom <code>SizeResolver</code> or use <code>rememberConstraintsSizeResolver</code> (which is what <code>AsyncImage</code> uses internally) to resolve this. Example:</p> <pre><code>val sizeResolver = rememberConstraintsSizeResolver()\nval painter = rememberAsyncImagePainter(\n    model = ImageRequest.Builder(LocalPlatformContext.current)\n        .data(\"https://example.com/image.jpg\")\n        .size(sizeResolver)\n        .build(),\n)\n\nImage(\n    painter = painter,\n    contentDescription = null,\n    modifier = Modifier.then(sizeResolver),\n)\n</code></pre> <p>Another drawback is <code>AsyncImagePainter.state</code> will always be <code>AsyncImagePainter.State.Empty</code> for the first composition when using <code>rememberAsyncImagePainter</code> - even if the image is present in the memory cache and it will be drawn in the first frame.</p>"},{"location":"compose/#subcomposeasyncimage","title":"SubcomposeAsyncImage","text":"<p><code>SubcomposeAsyncImage</code> is a variant of <code>AsyncImage</code> that uses subcomposition to provide a slot API for <code>AsyncImagePainter</code>'s states instead of using <code>Painter</code>s. Here's an example:</p> <pre><code>SubcomposeAsyncImage(\n    model = \"https://example.com/image.jpg\",\n    loading = {\n        CircularProgressIndicator()\n    },\n    contentDescription = stringResource(R.string.description),\n)\n</code></pre> <p>Additionally, you can have more complex logic using its <code>content</code> argument and <code>SubcomposeAsyncImageContent</code>, which renders the current state:</p> <pre><code>SubcomposeAsyncImage(\n    model = \"https://example.com/image.jpg\",\n    contentDescription = stringResource(R.string.description)\n) {\n    val state by painter.state.collectAsState()\n    if (state is AsyncImagePainter.State.Success) {\n        SubcomposeAsyncImageContent()\n    } else {\n        CircularProgressIndicator()\n    }\n}\n</code></pre> <p>Note</p> <p>Subcomposition is slower than regular composition so this composable may not be suitable for performance-critical parts of your UI (e.g. <code>LazyList</code>).</p> <p>When to use this function:</p> <p>Generally prefer using <code>rememberAsyncImagePainter</code> instead of this function if you need to observe <code>AsyncImagePainter.state</code> as it does not use subcomposition.</p> <p>Specifically, this function is only useful if you need to observe <code>AsyncImagePainter.state</code> and you can't have it be <code>Empty</code> for the first composition and first frame like with <code>rememberAsyncImagePainter</code>. <code>SubcomposeAsyncImage</code> uses subcomposition to get the image's constraints so it's <code>AsyncImagePainter.state</code> is up to date immediately.</p>"},{"location":"compose/#observing-asyncimagepainterstate","title":"Observing AsyncImagePainter.state","text":"<pre><code>val painter = rememberAsyncImagePainter(\"https://example.com/image.jpg\")\nval state by painter.state.collectAsState()\n\nwhen (state) {\n    is AsyncImagePainter.State.Empty,\n    is AsyncImagePainter.State.Loading -&gt; {\n        CircularProgressIndicator()\n    }\n    is AsyncImagePainter.State.Success -&gt; {\n        Image(\n            painter = painter,\n            contentDescription = stringResource(R.string.description)\n        )\n    }\n    is AsyncImagePainter.State.Error -&gt; {\n        // Show some error UI.\n    }\n}\n</code></pre>"},{"location":"compose/#transitions","title":"Transitions","text":"<p>You can enable the built in crossfade transition using <code>ImageRequest.Builder.crossfade</code>:</p> <pre><code>AsyncImage(\n    model = ImageRequest.Builder(LocalContext.current)\n        .data(\"https://example.com/image.jpg\")\n        .crossfade(true)\n        .build(),\n    contentDescription = null,\n)\n</code></pre> <p>Custom <code>Transition</code>s do not work with <code>AsyncImage</code>, <code>SubcomposeAsyncImage</code>, or <code>rememberAsyncImagePainter</code> as they require a <code>View</code> reference. <code>CrossfadeTransition</code> works due to special internal support.</p> <p>That said, it's possible to create custom transitions in Compose by observing <code>AsyncImagePainter.state</code>:</p> <pre><code>val painter = rememberAsyncImagePainter(\"https://example.com/image.jpg\")\n\nval state by painter.state.collectAsState()\nif (state is AsyncImagePainter.State.Success &amp;&amp; state.result.dataSource != DataSource.MEMORY_CACHE) {\n    // Perform the transition animation.\n}\n\nImage(\n    painter = painter,\n    contentDescription = stringResource(R.string.description),\n)\n</code></pre>"},{"location":"compose/#previews","title":"Previews","text":"<p>The Android Studio preview behaviour for <code>AsyncImage</code>/<code>rememberAsyncImagePainter</code>/<code>SubcomposeAsyncImage</code> is controlled by the <code>LocalAsyncImagePreviewHandler</code>. By default, it will attempt to perform the request as normal inside the preview environment. Network access is disabled in the preview environment so network URLs will always fail.</p> <p>You can override the preview behaviour like so:</p> <pre><code>val previewHandler = AsyncImagePreviewHandler {\n    ColorImage(Color.Red.toArgb())\n}\n\nCompositionLocalProvider(LocalAsyncImagePreviewHandler provides previewHandler) {\n    AsyncImage(\n        model = \"https://example.com/image.jpg\",\n        contentDescription = null,\n    )\n}\n</code></pre> <p>This is also useful for AndroidX's Compose Preview Screenshot Testing library, which executes in the same preview environment.</p>"},{"location":"compose/#compose-multiplatform-resources","title":"Compose Multiplatform Resources","text":"<p>Coil supports loading Compose Multiplatform Resources by using <code>Res.getUri</code> as the <code>model</code> parameter. Example:</p> <pre><code>AsyncImage(\n    model = Res.getUri(\"drawable/sample.jpg\"),\n    contentDescription = null,\n)\n</code></pre> <p>Note</p> <p><code>Res.drawable.image</code> and other compile-safe references are not supported by Coil. You must use <code>Res.getUri(\"drawable/image\")</code> instead. Follow this issue for updates.</p>"},{"location":"contributing/","title":"Contributing","text":"<p>In an effort to keep the library small and stable, please keep contributions limited to bug fixes, documentation improvements, and test improvements.</p> <p>Issues that are tagged as help wanted are great issues to get started contributing to Coil.</p> <p>If you have a new feature idea, please create an enhancement request so it can be discussed or build it in an external library.</p> <p>If you\u2019ve found a bug, please contribute a failing test case so we can study and fix it.</p> <p>If you would like to contribute code you can do so through GitHub by forking the repository and sending a pull request.</p> <p>When submitting code, please make every effort to follow existing conventions and style in order to keep the code as readable as possible. Please also make sure your code passes all tests by running <code>./test.sh</code>.</p> <p>If you are making an API change, run <code>./gradlew updateLegacyAbi</code> and include any changed files in your pull request.</p> <p>Modified from OkHttp's Contributing section.</p>"},{"location":"faq/","title":"FAQ","text":"<p>Have a question that isn't part of the FAQ? Check StackOverflow with the tag #coil or search Github discussions.</p>"},{"location":"faq/#can-coil-be-used-with-java-projects-or-mixed-kotlinjava-projects","title":"Can Coil be used with Java projects or mixed Kotlin/Java projects?","text":"<p>Yes! Read here.</p>"},{"location":"faq/#how-do-i-preload-an-image","title":"How do I preload an image?","text":"<p>Launch an image request with no target:</p> <pre><code>val request = ImageRequest.Builder(context)\n    .data(\"https://example.com/image.jpg\")\n    .build()\nimageLoader.enqueue(request)\n</code></pre> <p>That will preload the image and save it to the disk and memory caches.</p> <p>If you only want to preload to the disk cache you can skip decoding and saving to the memory cache like so:</p> <pre><code>val request = ImageRequest.Builder(context)\n    .data(\"https://example.com/image.jpg\")\n    // Disables writing to the memory cache.\n    .memoryCachePolicy(CachePolicy.DISABLED)\n    // Skips the decode step so we don't waste time/memory decoding the image into memory.\n    .decoderFactory(BlackholeDecoder.Factory())\n    .build()\nimageLoader.enqueue(request)\n</code></pre>"},{"location":"faq/#how-do-i-enable-logging","title":"How do I enable logging?","text":"<p>Set <code>logger(DebugLogger())</code> when constructing your <code>ImageLoader</code>.</p> <p>Note</p> <p><code>DebugLogger</code> should only be used in debug builds.</p>"},{"location":"faq/#how-do-i-target-java-8-or-java-11","title":"How do I target Java 8 or Java 11?","text":"<p>Coil requires Java 8 bytecode. This is enabled by default on the Android Gradle Plugin <code>4.2.0</code> and later and the Kotlin Gradle Plugin <code>1.5.0</code> and later. If you're using older versions of those plugins add the following to your Gradle build script:</p> <pre><code>android {\n    compileOptions {\n        sourceCompatibility = JavaVersion.VERSION_1_8\n        targetCompatibility = JavaVersion.VERSION_1_8\n    }\n    kotlinOptions {\n        jvmTarget = \"1.8\"\n    }\n}\n</code></pre> <p>As of Coil <code>3.2.0</code>, Java 11 bytecode is required for <code>coil-compose</code> and <code>coil-compose-core</code>:</p> <pre><code>android {\n    compileOptions {\n        sourceCompatibility = JavaVersion.VERSION_11\n        targetCompatibility = JavaVersion.VERSION_11\n    }\n    kotlinOptions {\n        jvmTarget = \"11\"\n    }\n}\n</code></pre>"},{"location":"faq/#how-do-i-get-development-snapshots","title":"How do I get development snapshots?","text":"<p>Add the snapshots repository to your list of repositories:</p> <p>Gradle (<code>.gradle</code>):</p> <pre><code>allprojects {\n    repositories {\n        maven { url 'https://central.sonatype.com/repository/maven-snapshots/' }\n    }\n}\n</code></pre> <p>Gradle Kotlin DSL (<code>.gradle.kts</code>):</p> <pre><code>allprojects {\n    repositories {\n        maven(\"https://central.sonatype.com/repository/maven-snapshots/\")\n    }\n}\n</code></pre> <p>Then depend on the same artifacts with the latest snapshot version.</p> <p>Note</p> <p>Snapshots are deployed for each new commit on <code>main</code> that passes CI. They can potentially contain breaking changes or may be unstable. Use at your own risk.</p>"},{"location":"faq/#how-to-i-use-proguard-with-coil","title":"How to I use Proguard with Coil?","text":"<p>To use Proguard with Coil, add the following rules to your config:</p> <pre><code>-keep class coil3.util.DecoderServiceLoaderTarget { *; }\n-keep class coil3.util.FetcherServiceLoaderTarget { *; }\n-keep class coil3.util.ServiceLoaderComponentRegistry { *; }\n-keep class * implements coil3.util.DecoderServiceLoaderTarget { *; }\n-keep class * implements coil3.util.FetcherServiceLoaderTarget { *; }\n</code></pre> <p>You may also need to add custom rules for Ktor, OkHttp, and Coroutines.</p> <p>Note</p> <p>You do not need to add any custom rules for Coil if you use R8, which is the default code shrinker on Android. The rules are added automatically.</p>"},{"location":"getting_started/","title":"Getting Started","text":""},{"location":"getting_started/#compose-ui","title":"Compose UI","text":"<p>A typical Compose UI project will want to import:</p> <pre><code>implementation(\"io.coil-kt.coil3:coil-compose:3.4.0\")\nimplementation(\"io.coil-kt.coil3:coil-network-okhttp:3.4.0\")\n</code></pre> <p>After that's imported you can load images from the network using <code>AsyncImage</code>:</p> <pre><code>AsyncImage(\n    model = \"https://example.com/image.jpg\",\n    contentDescription = null,\n)\n</code></pre> <p>Note</p> <p>If you use Compose Multiplatform, you'll need to use Ktor instead of OkHttp. See here for how to do that.</p>"},{"location":"getting_started/#android-views","title":"Android Views","text":"<p>If you use Android Views instead of Compose UI import:</p> <pre><code>implementation(\"io.coil-kt.coil3:coil:3.4.0\")\nimplementation(\"io.coil-kt.coil3:coil-network-okhttp:3.4.0\")\n</code></pre> <p>After that's imported you can load images from the network using the <code>ImageView.load</code> extension function:</p> <pre><code>imageView.load(\"https://example.com/image.jpg\")\n</code></pre>"},{"location":"getting_started/#configuring-the-singleton-imageloader","title":"Configuring the singleton ImageLoader","text":"<p>By default, Coil includes a singleton <code>ImageLoader</code>. The <code>ImageLoader</code> executes incoming <code>ImageRequest</code>s by fetching, decoding, caching, and returning the result. You don't need to configure your <code>ImageLoader</code>; if you don't Coil will create the singleton <code>ImageLoader</code> with the default configuration.</p> <p>You can configure it a number of ways (choose only one):</p> <ul> <li>Call <code>setSingletonImageLoaderFactory</code> near the entrypoint to your app (the root <code>@Composable</code> of your app). This works best for Compose Multiplatform apps.</li> </ul> <pre><code>setSingletonImageLoaderFactory { context -&gt;\n    ImageLoader.Builder(context)\n        .crossfade(true)\n        .build()\n}\n</code></pre> <ul> <li>Implement <code>SingletonImageLoader.Factory</code> on your <code>Application</code> in Android. This works best for Android apps.</li> </ul> <pre><code>class CustomApplication : Application(), SingletonImageLoader.Factory {\n    override fun newImageLoader(context: Context): ImageLoader {\n        return ImageLoader.Builder(context)\n            .crossfade(true)\n            .build()\n    }\n}\n</code></pre> <ul> <li>Call <code>SingletonImageLoader.setSafe</code> near the entrypoint to your app (e.g. in <code>Application.onCreate</code> on Android). This is the most flexible.</li> </ul> <pre><code>SingletonImageLoader.setSafe { context -&gt;\n    ImageLoader.Builder(context)\n        .crossfade(true)\n        .build()\n}\n</code></pre> <p>Note</p> <p>If you are writing a library that depends on Coil you should NOT get/set the singleton <code>ImageLoader</code>. Instead, you should depend on <code>io.coil-kt.coil3:coil-core</code>, create your own <code>ImageLoader</code>, and pass it around manually. If you set the singleton <code>ImageLoader</code> in your library you could be overwriting the <code>ImageLoader</code> set by the app using your library if they also use Coil.</p>"},{"location":"getting_started/#images","title":"Images","text":"<p>To support multiplatform rendering, Coil 3.x uses a custom <code>coil3.Image</code> class. It replaces Android's <code>Drawable</code>, but is fully interoperable with it:</p> <pre><code>val drawable = image.asDrawable(resources)\nval image = drawable.asImage()\n</code></pre> <p>Coil also defines a <code>coil3.Bitmap</code> class, which is a type alias for <code>android.graphics.Bitmap</code> on Android or <code>org.jetbrains.skia.Bitmap</code> on non-Android platforms:</p> <pre><code>val bitmap = image.toBitmap()\nval image = bitmap.asImage()\n</code></pre> <p>It's also interoperable with Compose UI's <code>Painter</code> class. This extension function requires importing the <code>coil-compose-core</code> artifact:</p> <pre><code>val painter = image.asPainter()\n</code></pre> <p>Note</p> <p><code>Painter</code>s can't be converted to <code>Image</code>s as painters can only be rendered inside a composition whereas <code>Image</code>s must be able to be rendered on any <code>Canvas</code>.</p>"},{"location":"getting_started/#artifacts","title":"Artifacts","text":"<p>Here's a list of the main artifacts Coil has published to <code>mavenCentral()</code>:</p> <ul> <li><code>io.coil-kt.coil3:coil</code>: The default artifact which depends on <code>io.coil-kt.coil3:coil-core</code>. It includes a singleton <code>ImageLoader</code> and related extension functions.</li> <li><code>io.coil-kt.coil3:coil-core</code>: A subset of <code>io.coil-kt.coil3:coil</code> which does not include the singleton <code>ImageLoader</code> and related extension functions.</li> <li><code>io.coil-kt.coil3:coil-compose</code>: The default Compose UI artifact which depends on <code>io.coil-kt.coil3:coil</code> and <code>io.coil-kt.coil3:coil-compose-core</code>. It includes overloads for <code>AsyncImage</code>, <code>rememberAsyncImagePainter</code>, and <code>SubcomposeAsyncImage</code> that use the singleton <code>ImageLoader</code>.</li> <li><code>io.coil-kt.coil3:coil-compose-core</code>: A subset of <code>io.coil-kt.coil3:coil-compose</code> which does not include functions that depend on the singleton <code>ImageLoader</code>.</li> <li><code>io.coil-kt.coil3:coil-network-okhttp</code>: Includes support for fetching images from the network using OkHttp.</li> <li><code>io.coil-kt.coil3:coil-network-ktor2</code>: Includes support for fetching images from the network using Ktor 2.</li> <li><code>io.coil-kt.coil3:coil-network-ktor3</code>: Includes support for fetching images from the network using Ktor 3.</li> <li><code>io.coil-kt.coil3:coil-network-cache-control</code>: Includes support for respecting <code>Cache-Control</code> headers when fetching images from the network.</li> <li><code>io.coil-kt.coil3:coil-gif</code>: Includes two decoders to support decoding GIFs. See GIFs for more details.</li> <li><code>io.coil-kt.coil3:coil-svg</code>: Includes a decoder to support decoding SVGs. See SVGs for more details.</li> <li><code>io.coil-kt.coil3:coil-video</code>: Includes a decoder to support decoding frames from any of Android's supported video formats. See videos for more details.</li> <li><code>io.coil-kt.coil3:coil-test</code>: Includes classes to support testing. See testing for more details.</li> <li><code>io.coil-kt.coil3:coil-bom</code>: Includes a bill of materials. Importing <code>coil-bom</code> allows you to depend on other Coil artifacts without specifying a version.</li> </ul>"},{"location":"gifs/","title":"Gifs","text":"<p>This feature is only available on Android.</p> <p>Unlike Glide, GIFs are not supported by default. However, Coil has an extension library to support them.</p> <p>To add GIF support, import the extension library:</p> <pre><code>implementation(\"io.coil-kt.coil3:coil-gif:3.4.0\")\n</code></pre> <p>And that's it! The <code>ImageLoader</code> will automatically detect any GIFs using their file headers and decode them correctly.</p> <p>Optionally, you can manually add the decoder to your component registry when constructing your <code>ImageLoader</code>:</p> <pre><code>val imageLoader = ImageLoader.Builder(context)\n    .components {\n        if (SDK_INT &gt;= 28) {\n            add(AnimatedImageDecoder.Factory())\n        } else {\n            add(GifDecoder.Factory())\n        }\n    }\n    .build()\n</code></pre> <p>To transform the pixel data of each frame of a GIF, see AnimatedTransformation.</p> <p>Note</p> <p>Coil includes two separate decoders to support decoding GIFs. <code>GifDecoder</code> supports all API levels, but is slower. <code>AnimatedImageDecoder</code> is powered by Android's ImageDecoder API which is only available on API 28 and above. <code>AnimatedImageDecoder</code> is faster than <code>GifDecoder</code> and supports decoding animated WebP images and animated HEIF image sequences.</p>"},{"location":"image_loaders/","title":"Image Loaders","text":"<p><code>ImageLoader</code>s are service objects that execute <code>ImageRequest</code>s. They handle caching, data fetching, image decoding, request management, memory management, and more.</p> <p>Coil performs best when you create a single <code>ImageLoader</code> and share it throughout your app. This is because each <code>ImageLoader</code> has its own memory cache, disk cache, and <code>OkHttpClient</code>.</p>"},{"location":"image_loaders/#singleton","title":"Singleton","text":"<p>The default <code>io.coil-kt.coil3:coil</code> artifact comes with a singleton <code>ImageLoader</code>. Coil creates this <code>ImageLoader</code> lazily. It can be configured a number of ways:</p> <pre><code>// The setSafe method ensures that it won't overwrite an\n// existing image loader that's been created.\nSingletonImageLoader.setSafe {\n    ImageLoader.Builder(context)\n        .crossfade(true)\n        .build()\n}\n\n// An alias of SingletonImageLoader.setSafe that's useful for\n// Compose Multiplatform apps.\nsetSingletonImageLoaderFactory { context -&gt;\n    ImageLoader.Builder(context)\n        .crossfade(true)\n        .build()\n}\n\n// Should only be used in tests. If you call this method\n// multiple times it will create multiple image loaders.\nSingletonImageLoader.setUnsafe {\n    ImageLoader.Builder(context)\n        .crossfade(true)\n        .build()\n}\n\n// On Android you can implement SingletonImageLoader.Factory on your\n// Application class to have it create the singleton image loader.\nclass CustomApplication : SingletonImageLoader.Factory {\n    override fun newImageLoader(context: Context): ImageLoader {\n        return ImageLoader.Builder(context)\n            .crossfade(true)\n            .build()\n    }\n}\n</code></pre> <p>In all cases ensure the above methods should be invoked as soon as possible when your app starts (i.e. inside <code>Application.onCreate</code> or inside <code>MainActivity.onCreate</code> if your app is only a single <code>Activity</code>.)</p>"},{"location":"image_loaders/#dependency-injection","title":"Dependency injection","text":"<p>If you have a larger app or want to manage your own <code>ImageLoaders</code> you can depend on <code>io.coil-kt.coil3:coil-core</code> instead of <code>io.coil-kt.coil3:coil</code>.</p> <p>This route makes scoping the lifecycle of a fake <code>ImageLoader</code> much easier and will overall make testing easier.</p>"},{"location":"image_loaders/#caching","title":"Caching","text":"<p>Each <code>ImageLoader</code> keeps a memory cache of recently decoded <code>Bitmap</code>s as well as a disk cache for any images loaded from the Internet. Both can be configured when creating an <code>ImageLoader</code>:</p> <pre><code>val imageLoader = ImageLoader.Builder(context)\n    .memoryCache {\n        MemoryCache.Builder()\n            .maxSizePercent(context, 0.25)\n            .build()\n    }\n    .diskCache {\n        DiskCache.Builder()\n            .directory(context.cacheDir.resolve(\"image_cache\"))\n            .maxSizePercent(0.02)\n            .build()\n    }\n    .build()\n</code></pre> <p>You can access items in the memory and disk caches using their keys, which are returned in an <code>ImageResult</code> after an image is loaded. The <code>ImageResult</code> is returned by <code>ImageLoader.execute</code> or in <code>ImageRequest.Listener.onSuccess</code> and <code>ImageRequest.Listener.onError</code>.</p>"},{"location":"image_pipeline/","title":"Extending the Image Pipeline","text":"<p>Android supports many image formats out of the box, however there are also plenty of formats it does not (e.g. GIF, SVG, MP4, etc.)</p> <p>Fortunately, ImageLoaders support pluggable components to add new cache layers, new data types, new fetching behavior, new image encodings, or otherwise overwrite the base image loading behavior. Coil's image pipeline consists of five main parts that are executed in the following order: Interceptors, Mappers, Keyers, Fetchers, and Decoders.</p> <p>Custom components must be added to the <code>ImageLoader</code> when constructing it through its ComponentRegistry:</p> <pre><code>val imageLoader = ImageLoader.Builder(context)\n    .components {\n        add(CustomCacheInterceptor())\n        add(ItemMapper())\n        add(HttpUrlKeyer())\n        add(CronetFetcher.Factory())\n        add(GifDecoder.Factory())\n    }\n    .build()\n</code></pre>"},{"location":"image_pipeline/#interceptors","title":"Interceptors","text":"<p>Interceptors allow you to observe, transform, short circuit, or retry requests to an <code>ImageLoader</code>'s image engine. For example, you can add a custom cache layer like so:</p> <pre><code>class CustomCacheInterceptor(\n    private val context: Context,\n    private val cache: LruCache&lt;String, Image&gt;,\n) : Interceptor {\n\n    override suspend fun intercept(chain: Interceptor.Chain): ImageResult {\n        val value = cache.get(chain.request.data.toString())\n        if (value != null) {\n            return SuccessResult(\n                image = value.bitmap.toImage(),\n                request = chain.request,\n                dataSource = DataSource.MEMORY_CACHE,\n            )\n        }\n        return chain.proceed(chain.request)\n    }\n}\n</code></pre> <p>Interceptors are an advanced feature that let you wrap an <code>ImageLoader</code>'s image pipeline with custom logic. Their design is heavily based on OkHttp's <code>Interceptor</code> interface.</p> <p>See Interceptor for more information.</p>"},{"location":"image_pipeline/#mappers","title":"Mappers","text":"<p>Mappers allow you to add support for custom data types. For instance, say we get this model from our server:</p> <pre><code>data class Item(\n    val id: Int,\n    val imageUrl: String,\n    val price: Int,\n    val weight: Double\n)\n</code></pre> <p>We could write a custom mapper to map it to its URL, which will be handled later in the pipeline:</p> <pre><code>class ItemMapper : Mapper&lt;Item, String&gt; {\n    override fun map(data: Item, options: Options) = data.imageUrl\n}\n</code></pre> <p>After registering it when building our <code>ImageLoader</code> (see above), we can safely load an <code>Item</code>:</p> <pre><code>val request = ImageRequest.Builder(context)\n    .data(item)\n    .target(imageView)\n    .build()\nimageLoader.enqueue(request)\n</code></pre> <p>See Mapper for more information.</p>"},{"location":"image_pipeline/#keyers","title":"Keyers","text":"<p>Keyers convert data into a portion of a cache key. This value is used as <code>MemoryCache.Key.key</code> when/if this request's output is written to the <code>MemoryCache</code>.</p> <p>See Keyers for more information.</p>"},{"location":"image_pipeline/#fetchers","title":"Fetchers","text":"<p>Fetchers translate data (e.g. URL, URI, File, etc.) into either an <code>ImageSource</code> or an <code>Image</code>. They typically convert the input data into a format that can then be consumed by a <code>Decoder</code>. Use this interface to add support for custom fetching mechanisms (e.g. Cronet, custom URI schemes, etc.)</p> <p>See Fetcher for more information.</p> <p>Note</p> <p>If you add a <code>Fetcher</code> that uses a custom data type, you need to also need to provide a custom <code>Keyer</code> to ensure results from requests that use it are memory cacheable. For example, <code>Fetcher.Factory&lt;MyDataType&gt;</code> will need to add a <code>Keyer&lt;MyDataType</code>.</p>"},{"location":"image_pipeline/#decoders","title":"Decoders","text":"<p>Decoders read an <code>ImageSource</code> and return an <code>Image</code>. Use this interface to add support for custom file formats (e.g. GIF, SVG, TIFF, etc.).</p> <p>See Decoder for more information.</p>"},{"location":"image_pipeline/#custom-imageloader-and-imagerequest-properties","title":"Custom ImageLoader and ImageRequest properties","text":"<p>Coil supports attaching custom data to <code>ImageRequest</code>s and <code>ImageLoader</code>s through their <code>Extras</code>. <code>Extras</code> are a map of extra properties that are referenced via an <code>Extras.Key</code>.</p> <p>For example, say we want to support a custom timeout for each <code>ImageRequest</code>. We could add custom extension functions for it like so:</p> <pre><code>fun ImageRequest.Builder.timeout(timeout: Duration) = apply {\n    extras[timeoutKey] = timeout\n}\n\nfun ImageLoader.Builder.timeout(timeout: Duration) = apply {\n    extras[timeoutKey] = timeout\n}\n\nval ImageRequest.timeout: Duration\n    get() = getExtra(timeoutKey)\n\nval Options.timeout: Duration\n    get() = getExtra(timeoutKey)\n\n// NOTE: Extras.Key instances should be declared statically as they're compared with instance equality.\nprivate val timeoutKey = Extras.Key(default = Duration.INFINITE)\n</code></pre> <p>Then we can read the property inside a custom <code>Interceptor</code> that we'll register in our <code>ImageLoader</code>:</p> <pre><code>class TimeoutInterceptor : Interceptor {\n    override suspend fun intercept(chain: Interceptor.Chain): ImageResult {\n        val timeout = chain.request.timeout\n        if (timeout.isFinite()) {\n            return withTimeout(timeout) {\n                chain.proceed(chain.request)\n            }\n        } else {\n            return chain.proceed(chain.request)\n        }\n    }\n}\n</code></pre> <p>Finally, we can set the property when creating our <code>ImageRequest</code>:</p> <pre><code>AsyncImage(\n    model = ImageRequest.Builder(PlatformContext.current)\n        .data(\"https://example.com/image.jpg\")\n        .timeout(10.seconds)\n        .build(),\n    contentDescription = null,\n)\n</code></pre> <p>Additionally:</p> <ul> <li>We can set a default timeout value via the <code>ImageLoader.Builder.timeout</code> extension function we defined.</li> <li>We can read the timeout inside <code>Mapper</code>s, <code>Fetcher</code>s, and <code>Decoder</code>s via the <code>Options.timeout</code> extension function we defined.</li> </ul> <p>Coil uses this pattern itself to support custom request properties for GIFs in <code>coil-gif</code> as well as other extension libraries.</p>"},{"location":"image_pipeline/#chaining-components","title":"Chaining components","text":"<p>A useful property of Coil's image loader components is that they can be chained internally. For example, say you need to perform a network request to get the image URL that will be loaded.</p> <p>First, let's create a custom data type that only our fetcher will handle:</p> <pre><code>data class PartialUrl(\n    val baseUrl: String,\n)\n</code></pre> <p>Then let's create our custom <code>Fetcher</code> that will get the image URL and delegate to the internal network fetcher:</p> <pre><code>class PartialUrlFetcher(\n    private val callFactory: Call.Factory,\n    private val partialUrl: PartialUrl,\n    private val options: Options,\n    private val imageLoader: ImageLoader,\n) : Fetcher {\n\n    override suspend fun fetch(): FetchResult? {\n        val request = Request.Builder()\n            .url(partialUrl.baseUrl)\n            .build()\n        val response = callFactory.newCall(request).await()\n\n        // Read the image URL.\n        val imageUrl: String = readImageUrl(response.body)\n\n        // This will delegate to the internal network fetcher.\n        val data = imageLoader.components.map(imageUrl, options)\n        val output = imageLoader.components.newFetcher(data, options, imageLoader)\n        val (fetcher) = checkNotNull(output) { \"no supported fetcher\" }\n        return fetcher.fetch()\n    }\n\n    class Factory(\n        private val callFactory: Call.Factory = OkHttpClient(),\n    ) : Fetcher.Factory&lt;PartialUrl&gt; {\n        override fun create(data: PartialUrl, options: Options, imageLoader: ImageLoader): Fetcher {\n            return PartialUrlFetcher(callFactory, data, options, imageLoader)\n        }\n    }\n}\n</code></pre> <p>Finally all we have to do is register the <code>Fetcher</code> in our <code>ComponentRegistry</code> and pass a <code>PartialUrl</code> as our <code>model</code>/<code>data</code>:</p> <pre><code>AsyncImage(\n    model = PartialUrl(\"https://example.com/image.jpg\"),\n    contentDescription = null,\n)\n</code></pre> <p>This pattern can similarly be applied to <code>Mapper</code>s, <code>Keyer</code>s, and <code>Decoder</code>s.</p>"},{"location":"image_requests/","title":"Image Requests","text":"<p><code>ImageRequest</code>s are value objects that provide all the necessary information for an ImageLoader to load an image. <code>ImageRequest</code>s can be created using a builder:</p> <pre><code>val request = ImageRequest.Builder(context)\n    .data(\"https://example.com/image.jpg\")\n    .crossfade(true)\n    .target(imageView)\n    .build()\n</code></pre> <p>Once you've created a request pass it to an <code>ImageLoader</code> to enqueue/execute it:</p> <pre><code>imageLoader.enqueue(request)\n</code></pre> <p>See the API documentation for more information.</p> <p>Notes</p> <p>In Coil 3.x <code>ImageRequest</code>'s platform-specific functions (e.g. <code>ImageRequest.Builder.target(ImageView)</code>) are implemented as extension functions and need to be imported separately.</p>"},{"location":"java_compatibility/","title":"Java Compatibility","text":"<p>Coil's API is designed to be Kotlin-first. It leverages Kotlin language features such as inlined lambdas, receiver params, default arguments, and extension functions, which are not available in Java.</p> <p>Importantly, suspend functions cannot be implemented in Java. This means custom Transformations, Size Resolvers, Fetchers, and Decoders must be implemented in Kotlin.</p> <p>Despite these limitations, most of Coil's API is Java compatible. You can get the singleton <code>ImageLoader</code> using:</p> <pre><code>ImageLoader imageLoader = SingletonImageLoader.get(context);\n</code></pre> <p>The syntax to enqueue an <code>ImageRequest</code> is almost the same in Java and Kotlin:</p> <pre><code>ImageRequest request = new ImageRequest.Builder(context)\n    .data(\"https://example.com/image.jpg\")\n    .crossfade(true)\n    .target(new ImageViewTarget(imageView))\n    .build();\nimageLoader.enqueue(request);\n</code></pre> <p>Note</p> <p><code>ImageView.load</code> cannot be used from Java. Use the <code>ImageRequest.Builder</code> API instead.</p> <p><code>suspend</code> functions cannot be easily called from Java. Thus, to get an image synchronously you'll have to use the <code>ImageLoader.executeBlocking</code> extension function which can be called from Java like so:</p> <pre><code>ImageRequest request = new ImageRequest.Builder(context)\n    .data(\"https://example.com/image.jpg\")\n    .size(1080, 1920)\n    .build();\nImage image = ImageLoaders.executeBlocking(imageLoader, request).getImage();\nDrawable drawable = Image_androidKt.asDrawable(image, context. resources);\n</code></pre> <p>Note</p> <p><code>ImageLoaders.executeBlocking</code> will block the current thread instead of suspending. Do not call this from the main thread.</p>"},{"location":"migrating/","title":"Migrating from Glide/Picasso","text":"<p>Here are a few examples of how to migrate Glide/Picasso calls into Coil calls:</p>"},{"location":"migrating/#basic-usage","title":"Basic Usage","text":"<pre><code>// Glide\nGlide.with(context)\n    .load(url)\n    .into(imageView)\n\n// Picasso\nPicasso.get()\n    .load(url)\n    .into(imageView)\n\n// Coil\nimageView.load(url)\n</code></pre>"},{"location":"migrating/#custom-requests","title":"Custom Requests","text":"<pre><code>imageView.scaleType = ImageView.ScaleType.FIT_CENTER\n\n// Glide\nGlide.with(context)\n    .load(url)\n    .placeholder(placeholder)\n    .fitCenter()\n    .into(imageView)\n\n// Picasso\nPicasso.get()\n    .load(url)\n    .placeholder(placeholder)\n    .fit()\n    .into(imageView)\n\n// Coil (automatically detects the scale type)\nimageView.load(url) {\n    placeholder(placeholder)\n}\n</code></pre>"},{"location":"migrating/#non-view-targets","title":"Non-View Targets","text":"<pre><code>// Glide (has optional callbacks for start and error)\nGlide.with(context)\n    .load(url)\n    .into(object : CustomTarget&lt;Drawable&gt;() {\n        override fun onResourceReady(resource: Drawable, transition: Transition&lt;Drawable&gt;) {\n            // Handle the successful result.\n        }\n\n        override fun onLoadCleared(placeholder: Drawable) {\n            // Remove the drawable provided in onResourceReady from any Views and ensure no references to it remain.\n        }\n    })\n\n// Picasso\nPicasso.get()\n    .load(url)\n    .into(object : BitmapTarget {\n        override fun onBitmapLoaded(bitmap: Bitmap, from: Picasso.LoadedFrom) {\n            // Handle the successful result.\n        }\n\n        override fun onBitmapFailed(e: Exception, errorDrawable: Drawable?) {\n            // Handle the error drawable.\n        }\n\n        override fun onPrepareLoad(placeHolderDrawable: Drawable?) {\n            // Handle the placeholder drawable.\n        }\n    })\n\n// Coil\nval request = ImageRequest.Builder(context)\n    .data(url)\n    .target(\n        onStart = { placeholder -&gt;\n            // Handle the placeholder image.\n        },\n        onSuccess = { result -&gt;\n            // Handle the successful result.\n        },\n        onError = { error -&gt;\n            // Handle the error image.\n        }\n    )\n    .build()\ncontext.imageLoader.enqueue(request)\n</code></pre>"},{"location":"migrating/#background-thread","title":"Background Thread","text":"<pre><code>// Glide (blocks the current thread; must not be called from the main thread)\nval drawable = Glide.with(context)\n    .load(url)\n    .submit(width, height)\n    .get()\n\n// Picasso (blocks the current thread; must not be called from the main thread)\nval drawable = Picasso.get()\n    .load(url)\n    .resize(width, height)\n    .get()\n\n// Coil (suspends, non-blocking, and thread safe)\nval request = ImageRequest.Builder(context)\n    .data(url)\n    .size(width, height)\n    .build()\nval drawable = context.imageLoader.execute(request).image.asDrawable(resources)\n</code></pre>"},{"location":"network/","title":"Network Images","text":"<p>By default, Coil 3.x does not include support for loading images from the network. This is to avoid forcing a large networking dependency on users who want to use their own networking solution or do not need network URL support (e.g. only loading images from disk).</p> <p>To add support for fetching images from the network import only one of the following:</p> <pre><code>implementation(\"io.coil-kt.coil3:coil-network-okhttp:3.4.0\") // Only available on Android/JVM.\nimplementation(\"io.coil-kt.coil3:coil-network-ktor2:3.4.0\")\nimplementation(\"io.coil-kt.coil3:coil-network-ktor3:3.4.0\")\n</code></pre> <p>If you use OkHttp, that's it. Once imported, network URLs like <code>https://example.com/image.jpg</code> will automatically be supported. If you use Ktor, you need to add supported engines for each platform (see below).</p>"},{"location":"network/#ktor-network-engines","title":"Ktor network engines","text":"<p>If you depend on <code>coil-network-ktor2</code> or <code>coil-network-ktor3</code> you need to import a Ktor engine for each platform (except Javascript). Here's a quickstart set of engines:</p> <pre><code>androidMain {\n    dependencies {\n        implementation(\"io.ktor:ktor-client-android:&lt;ktor-version&gt;\")\n    }\n}\nappleMain {\n    dependencies {\n        implementation(\"io.ktor:ktor-client-darwin:&lt;ktor-version&gt;\")\n    }\n}\njvmMain {\n    dependencies {\n        implementation(\"io.ktor:ktor-client-java:&lt;ktor-version&gt;\")\n    }\n}\n</code></pre> <p>If you want to use a custom networking library, you can import <code>io.coil-kt.coil3:coil-network-core</code>, implement <code>NetworkClient</code>, and register <code>NetworkFetcher</code> with your custom <code>NetworkClient</code> in your <code>ImageLoader</code>.</p>"},{"location":"network/#using-a-custom-okhttpclient","title":"Using a custom OkHttpClient","text":"<p>If you use <code>io.coil-kt.coil3:coil-network-okhttp</code> You can specify a custom <code>OkHttpClient</code> when creating your <code>ImageLoader</code>:</p> <pre><code>val imageLoader = ImageLoader.Builder(context)\n    .components {\n        add(\n            OkHttpNetworkFetcherFactory(\n                callFactory = {\n                    OkHttpClient()\n                }\n            )\n        )\n    }\n    .build()\n</code></pre> <p>Note</p> <p>If you already have a built <code>OkHttpClient</code>, use <code>newBuilder()</code> to build a new client that shares resources with the original.</p>"},{"location":"network/#cache-control-support","title":"Cache-Control support","text":"<p>By default, Coil 3.x does not respect <code>Cache-Control</code> headers and always saves a response to its disk cache.</p> <p><code>io.coil-kt.coil3:coil-network-cache-control</code> includes a <code>CacheStrategy</code> implementation that ensures that <code>NetworkFetcher</code> respects a network response's <code>Cache-Control</code> header.</p> <p>Pass <code>CacheControlCacheStrategy</code> to your <code>NetworkFetcher</code> then register the custom <code>NetworkFetcher</code> in your <code>ImageLoader</code>:</p> <pre><code>OkHttpNetworkFetcherFactory(\n    cacheStrategy = { CacheControlCacheStrategy() },\n)\n</code></pre> <p>Note</p> <p>You need to enable <code>coreLibraryDesugaring</code> to support Android API level 25 or below. Follow the docs here to enable it.</p>"},{"location":"network/#headers","title":"Headers","text":"<p>Headers can be added to your image requests in one of two ways. You can set headers for a single request:</p> <pre><code>val headers = NetworkHeaders.Builder()\n    .set(\"Cache-Control\", \"no-cache\")\n    .build()\nval request = ImageRequest.Builder(context)\n    .data(\"https://example.com/image.jpg\")\n    .httpHeaders(headers)\n    .target(imageView)\n    .build()\nimageLoader.execute(request)\n</code></pre> <p>Or you can create an OkHttp <code>Interceptor</code> that sets headers for every request executed by your <code>ImageLoader</code>:</p> <pre><code>class RequestHeaderInterceptor(\n    private val name: String,\n    private val value: String,\n) : Interceptor {\n\n    override fun intercept(chain: Interceptor.Chain): Response {\n        val headers = Headers.Builder()\n            .set(\"Cache-Control\", \"no-cache\")\n            .build()\n        val request = chain.request().newBuilder()\n            .headers(headers)\n            .build()\n        return chain.proceed(request)\n    }\n}\n\nval imageLoader = ImageLoader.Builder(context)\n    .components {\n        add(\n            OkHttpNetworkFetcher(\n                callFactory = {\n                    OkHttpClient.Builder()\n                        // This header will be added to every image request.\n                        .addNetworkInterceptor(RequestHeaderInterceptor(\"Cache-Control\", \"no-cache\"))\n                        .build()\n                },\n            )\n        )\n    }\n    .build()\n</code></pre>"},{"location":"recipes/","title":"Recipes","text":"<p>This page provides guidance on how to handle some common use cases with Coil. You might have to modify this code to fit your exact requirements, but it should hopefully give you a push in the right direction!</p> <p>See a common use case that isn't covered? Feel free to submit a PR with a new section.</p>"},{"location":"recipes/#palette","title":"Palette","text":"<p>Palette allows you to extract prominent colors from an image. To create a <code>Palette</code>, you'll need access to an image's <code>Bitmap</code>. This can be done in a number of ways:</p> <p>You can get access to an image's bitmap by setting a <code>ImageRequest.Listener</code> and enqueuing an <code>ImageRequest</code>:</p> <pre><code>imageView.load(\"https://example.com/image.jpg\") {\n    // Disable hardware bitmaps as Palette needs to read the image's pixels.\n    allowHardware(false)\n    listener(\n        onSuccess = { _, result -&gt;\n            // Create the palette on a background thread.\n            Palette.Builder(result.image.toBitmap()).generate { palette -&gt;\n                // Consume the palette.\n            }\n        }\n    )\n}\n</code></pre>"},{"location":"recipes/#using-a-memory-cache-key-as-a-placeholder","title":"Using a Memory Cache Key as a Placeholder","text":"<p>Using a previous request's <code>MemoryCache.Key</code> as a placeholder for a subsequent request can be useful if the two images are the same, though loaded at different sizes. For instance, if the first request loads the image at 100x100 and the second request loads the image at 500x500, we can use the first image as a synchronous placeholder for the second request.</p> <p>Here's what this effect looks like in the sample app:</p> <p> </p> <p>Images in the list have intentionally been loaded with very low detail and the crossfade is slowed down to highlight the visual effect.</p> <p>To achieve this effect, use the <code>MemoryCache.Key</code> of the first request as the <code>ImageRequest.placeholderMemoryCacheKey</code> of the second request. Here's an example:</p> <pre><code>// First request\nlistImageView.load(\"https://example.com/image.jpg\")\n\n// Second request (once the first request finishes)\ndetailImageView.load(\"https://example.com/image.jpg\") {\n    placeholderMemoryCacheKey(listImageView.result.memoryCacheKey)\n}\n</code></pre>"},{"location":"recipes/#shared-element-transitions","title":"Shared Element Transitions","text":"<p>Shared element transitions allow you to animate between <code>Activities</code> and <code>Fragments</code>. Here are some recommendations on how to get them to work with Coil:</p> <ul> <li> <p>Shared element transitions are incompatible with hardware bitmaps. You should set <code>allowHardware(false)</code> to disable hardware bitmaps for both the <code>ImageView</code> you are animating from and the view you are animating to. If you don't, the transition will throw an <code>java.lang.IllegalArgumentException: Software rendering doesn't support hardware bitmaps</code> exception.</p> </li> <li> <p>Use the <code>MemoryCache.Key</code> of the start image as the <code>placeholderMemoryCacheKey</code> for the end image. This ensures that the start image is used as the placeholder for the end image, which results in a smooth transition with no white flashes if the image is in the memory cache.</p> </li> <li> <p>Use <code>ChangeImageTransform</code> and <code>ChangeBounds</code> together for optimal results.</p> </li> </ul> <p>Using Compose? Check out this article for how to perform shared element transitions with <code>AsyncImage</code>.</p>"},{"location":"recipes/#remote-views","title":"Remote Views","text":"<p>Coil does not provide a <code>Target</code> for <code>RemoteViews</code> out of the box, however you can create one like so:</p> <pre><code>class RemoteViewsTarget(\n    private val context: Context,\n    private val componentName: ComponentName,\n    private val remoteViews: RemoteViews,\n    @IdRes private val imageViewResId: Int\n) : Target {\n\n    override fun onStart(placeholder: Image?) = setImage(placeholder)\n\n    override fun onError(error: Image?) = setImage(error)\n\n    override fun onSuccess(result: Image) = setImage(result)\n\n    private fun setImage(image: Image?) {\n        remoteViews.setImageViewBitmap(imageViewResId, image?.toBitmap())\n        AppWidgetManager.getInstance(context).updateAppWidget(componentName, remoteViews)\n    }\n}\n</code></pre> <p>Then <code>enqueue</code>/<code>execute</code> the request like normal:</p> <pre><code>val request = ImageRequest.Builder(context)\n    .data(\"https://example.com/image.jpg\")\n    .target(RemoteViewsTarget(context, componentName, remoteViews, imageViewResId))\n    .build()\nimageLoader.enqueue(request)\n</code></pre>"},{"location":"recipes/#transforming-painters","title":"Transforming Painters","text":"<p>Both <code>AsyncImage</code> and <code>AsyncImagePainter</code> have <code>placeholder</code>/<code>error</code>/<code>fallback</code> arguments that accept <code>Painter</code>s. Painters are less flexible than using composables, but are faster as Coil doesn't need to use subcomposition. That said, it may be necessary to inset, stretch, tint, or transform your painter to get the desired UI. To accomplish this, copy this Gist into your project and wrap the painter like so:</p> <pre><code>AsyncImage(\n    model = \"https://example.com/image.jpg\",\n    contentDescription = null,\n    placeholder = forwardingPainter(\n        painter = painterResource(R.drawable.placeholder),\n        colorFilter = ColorFilter(Color.Red),\n        alpha = 0.5f,\n    ),\n)\n</code></pre> <p>The <code>onDraw</code> can be overwritten using a trailing lambda:</p> <pre><code>AsyncImage(\n    model = \"https://example.com/image.jpg\",\n    contentDescription = null,\n    placeholder = forwardingPainter(painterResource(R.drawable.placeholder)) { info -&gt;\n        inset(50f, 50f) {\n            with(info.painter) {\n                draw(size, info.alpha, info.colorFilter)\n            }\n        }\n    },\n)\n</code></pre>"},{"location":"recipes/#transforming-requests","title":"Transforming Requests","text":"<p>You may need to transform HTTP requests used to fetch images. In this example, we'll use an Interceptor to append <code>width</code> &amp; <code>height</code> query parameters to the request URL.</p> <pre><code>class UrlSizeInterceptor : Interceptor {\n\n    override suspend fun intercept(chain: Chain): ImageResult {\n        val request = chain.request\n        val uri = request.uri\n\n        if (uri == null || uri.scheme !in setOf(\"https\", \"http\")) {\n            // Ignore non-HTTP requests.\n            return chain.proceed()\n        }\n\n        val (width, height) = chain.size\n        return if (width is Pixels &amp;&amp; height is Pixels) {\n            val transformUri = uri.newBuilder()\n                .query(\"width=${width.px}&amp;height=${height.px}\")\n                .build()\n\n            val transformedRequest = request.newBuilder()\n                .data(transformUri)\n                .build()\n            return chain.withRequest(transformedRequest).proceed()\n        } else {\n            // Width &amp; height aren't available, i.e. because of infinite constraints.\n            chain.proceed()\n        }\n    }\n\n    private val ImageRequest.uri: Uri?\n        get() = when (val data = data) {\n            is Uri -&gt; data\n            is coil3.Uri -&gt; data.toAndroidUri()\n            is String -&gt; data.toUri()\n            else -&gt; null\n        }\n}\n</code></pre> <p>Don't forget to register add interceptor to your <code>ImageLoader</code>!</p> <pre><code>ImageLoader.Builder(context)\n    .components {\n        add(UrlSizeInterceptor())\n    }\n    .build()\n</code></pre>"},{"location":"svgs/","title":"SVGs","text":"<p>To add SVG support, import the extension library:</p> <pre><code>implementation(\"io.coil-kt.coil3:coil-svg:3.4.0\")\n</code></pre> <p>And that's it! The <code>ImageLoader</code> will automatically detect and decode any SVGs. Coil detects SVGs by looking for the <code>&lt;svg</code> marker in the first 1 KB of the file, which should cover most cases. If the SVG is not automatically detected, you can set the <code>Decoder</code> explicitly for the request:</p> <pre><code>imageView.load(\"/path/to/svg\") {\n    decoderFactory { result, options, _ -&gt; SvgDecoder(result.source, options) }\n}\n</code></pre> <p>Optionally, you can manually add the decoder to your component registry when constructing your <code>ImageLoader</code>:</p> <pre><code>val imageLoader = ImageLoader.Builder(context)\n    .components {\n        add(SvgDecoder.Factory())\n    }\n    .build()\n</code></pre>"},{"location":"testing/","title":"Testing","text":"<p>To use the testing support classes, import the extension library:</p> <pre><code>testImplementation(\"io.coil-kt.coil3:coil-test:3.4.0\")\n</code></pre> <p><code>coil-test</code> includes a <code>FakeImageLoaderEngine</code>, which can be added to your <code>ImageLoader</code> to intercept all incoming <code>ImageRequest</code>s and return a custom <code>ImageResult</code>. This is useful for testing as it makes loading images synchronous (from the main thread) and consistent. By using <code>FakeImageLoaderEngine</code> the <code>ImageLoader</code> will avoid all the memory caching, thread jumping, disk/network I/O fetching, and image decoding that's typically done to load an image. Here's an example:</p> <pre><code>val engine = FakeImageLoaderEngine.Builder()\n    .intercept(\"https://example.com/image.jpg\", ColorImage(Color.Red.toArgb()))\n    .intercept({ it is String &amp;&amp; it.endsWith(\"test.png\") }, ColorImage(Color.Green.toArgb()))\n    .default(ColorImage(Color.Blue.toArgb()))\n    .build()\nval imageLoader = ImageLoader.Builder(context)\n    .components { add(engine) }\n    .build()\n</code></pre> <p><code>ColorImage</code> is useful for testing as it can draw a colored box or fill the canvas with a color depending on its width/height and it is supported on all platforms.</p> <p>This strategy works great with Paparazzi to screenshot test UIs without a physical device or emulator:</p> <pre><code>class PaparazziTest {\n    @get:Rule\n    val paparazzi = Paparazzi()\n\n    @Before\n    fun before() {\n        val engine = FakeImageLoaderEngine.Builder()\n            .intercept(\"https://example.com/image.jpg\", ColorImage(Color.Red.toArgb()))\n            .intercept({ it is String &amp;&amp; it.endsWith(\"test.png\") }, ColorImage(Color.Green.toArgb()))\n            .default(ColorImage(Color.Blue.toArgb()))\n            .build()\n        val imageLoader = ImageLoader.Builder(paparazzi.context)\n            .components { add(engine) }\n            .build()\n        SingletonImageLoader.setUnsafe(imageLoader)\n    }\n\n    @Test\n    fun testContentComposeRed() {\n        // Will display a red box.\n        paparazzi.snapshot {\n            AsyncImage(\n                model = \"https://example.com/image.jpg\",\n                contentDescription = null,\n            )\n        }\n    }\n\n    @Test\n    fun testContentComposeGreen() {\n        // Will display a green box.\n        paparazzi.snapshot {\n            AsyncImage(\n                model = \"https://www.example.com/test.png\",\n                contentDescription = null,\n            )\n        }\n    }\n\n    @Test\n    fun testContentComposeBlue() {\n        // Will display a blue box.\n        paparazzi.snapshot {\n            AsyncImage(\n                model = \"https://www.example.com/default.png\",\n                contentDescription = null,\n            )\n        }\n    }\n}\n</code></pre>"},{"location":"upgrading_to_coil2/","title":"Upgrading to Coil 2.x","text":"<p>This is a short guide to highlight the main changes when upgrading from Coil 1.x to 2.x and how to handle them. This upgrade guide doesn't cover every binary or source incompatible change, but it does cover the most important changes.</p>"},{"location":"upgrading_to_coil2/#minimum-api-21","title":"Minimum API 21","text":"<p>Coil 2.x requires minimum API 21. This is also the minimum API required for Compose and OkHttp 4.x.</p>"},{"location":"upgrading_to_coil2/#imagerequest-default-scale","title":"ImageRequest default scale","text":"<p>Coil 2.x changes <code>ImageRequest</code>'s default scale from <code>Scale.FILL</code> to <code>Scale.FIT</code>. This was done to be consistent with <code>ImageView</code>'s default <code>ScaleType</code> and <code>Image</code>'s default <code>ContentScale</code>. Scale is still autodetected if you set an <code>ImageView</code> as your <code>ImageRequest.target</code>.</p>"},{"location":"upgrading_to_coil2/#size-refactor","title":"Size refactor","text":"<p><code>Size</code>'s <code>width</code> and <code>height</code> are now two <code>Dimension</code>s instead of <code>Int</code> pixel values. <code>Dimension</code> is either a pixel value or <code>Dimension.Undefined</code>, which represents an undefined/unbounded constraint. For example, if the size is <code>Size(400, Dimension.Undefined)</code> that means the image should be scaled to have 400 pixels for its width irrespective of its height. You can use the <code>pxOrElse</code> extension to get the pixel value (if present), else use a fallback:</p> <pre><code>val width = size.width.pxOrElse { -1 }\nif (width &gt; 0) {\n    // Use the pixel value.\n}\n</code></pre> <p>This change was made to improve support for cases where a target has one unbounded dimension (e.g. if one dimension is <code>ViewGroup.LayoutParams.WRAP_CONTENT</code> for a <code>View</code> or <code>Constraints.Infinity</code> in Compose).</p>"},{"location":"upgrading_to_coil2/#compose","title":"Compose","text":"<p>Coil 2.x significantly reworks the Compose integration to add features, improve stability, and improve performance.</p> <p>In Coil 1.x you would use <code>rememberImagePainter</code> to load an image:</p> <pre><code>val painter = rememberImagePainter(\"https://example.com/image.jpg\") {\n    crossfade(true)\n}\n\nImage(\n    painter = painter,\n    contentDescription = null,\n    contentScale = ContentScale.Crop\n)\n</code></pre> <p>In Coil 2.x <code>rememberImagePainter</code> has been changed to <code>rememberAsyncImagePainter</code> with the following changes:</p> <ul> <li>The trailing lambda argument to configure the <code>ImageRequest</code> has been removed.</li> <li>In Coil 2.x, <code>rememberAsyncImagePainter</code> defaults to using <code>ContentScale.Fit</code> to be consistent with <code>Image</code> whereas in Coil 1.x it would default to <code>ContentScale.Crop</code>. As such, if you set a custom <code>ContentScale</code> on <code>Image</code>, you now also need to pass it to <code>rememberAsyncImagePainter</code>.</li> </ul> <pre><code>val painter = rememberAsyncImagePainter(\n    model = ImageRequest.Builder(LocalContext.current)\n        .data(\"https://example.com/image.jpg\")\n        .crossfade(true)\n        .build(),\n    contentScale = ContentScale.Crop\n)\n\nImage(\n    painter = painter,\n    contentDescription = null,\n    contentScale = ContentScale.Crop\n)\n</code></pre> <p>Additionally, Coil now has <code>AsyncImage</code> and <code>SubcomposeAsyncImage</code> composable functions, which add new features and work-around some design limitations of <code>rememberAsyncImagePainter</code>. Check out the full Compose docs here.</p>"},{"location":"upgrading_to_coil2/#disk-cache","title":"Disk Cache","text":"<p>Coil 2.x has its own public disk cache class that can be accessed using <code>imageLoader.diskCache</code>. Coil 1.x relied on OkHttp's disk cache, however it's no longer needed.</p> <p>To configure the disk cache in 1.x you would use <code>CoilUtils.createDefaultCache</code>:</p> <pre><code>ImageLoader.Builder(context)\n    .okHttpClient {\n        OkHttpClient.Builder().cache(CoilUtils.createDefaultCache(context)).build()\n    }\n    .build()\n</code></pre> <p>In Coil 2.x you should not set a <code>Cache</code> object on your <code>OkHttpClient</code> when used with an <code>ImageLoader</code>. Instead configure the disk cache object like so:</p> <pre><code>ImageLoader.Builder(context)\n    .diskCache {\n        DiskCache.Builder()\n            .directory(context.cacheDir.resolve(\"image_cache\"))\n            .build()\n    }\n    .build()\n</code></pre> <p>This change was made to add functionality and improve performance:</p> <ul> <li>Support thread interruption while decoding images.</li> <li>Thread interruption allows fast cancellation of decode operations. This is particularly important for quickly scrolling through a list.</li> <li>By using a custom disk cache Coil is able to ensure a network source is fully read to disk before decoding. This is necessary as writing the data to disk cannot be interrupted - only the decode step can be interrupted. OkHttp's <code>Cache</code> shouldn't be used with Coil 2.0 as it's not possible to guarantee that all data is written to disk before decoding.</li> <li>Avoid buffering/creating temporary files for decode APIs that don't support <code>InputStream</code>s or require direct access to a <code>File</code> (e.g. <code>ImageDecoder</code>, <code>MediaMetadataRetriever</code>).</li> <li>Add a public read/write <code>DiskCache</code> API.</li> </ul> <p>In Coil 2.x <code>Cache-Control</code> and other cache headers are still supported - except <code>Vary</code> headers, as the cache only checks that the URLs match. Additionally, only responses with a response code in the range [200..300) are cached.</p> <p>When upgrading from Coil 1.x to 2.x, any existing disk cache will be cleared as the internal format has changed.</p>"},{"location":"upgrading_to_coil2/#image-pipeline-refactor","title":"Image pipeline refactor","text":"<p>Coil 2.x refactors the image pipeline classes to be more flexible. Here's a high-level list of the changes:</p> <ul> <li>Introduce a new class, <code>Keyer</code>, that computes the memory cache key for a request. It replaces <code>Fetcher.key</code>.</li> <li><code>Mapper</code>, <code>Keyer</code>, <code>Fetcher</code>, and <code>Decoder</code> can return <code>null</code> to delegate to the next element in the list of components.</li> <li>Add <code>Options</code> to <code>Mapper.map</code>'s signature.</li> <li>Introduce <code>Fetcher.Factory</code> and <code>Decoder.Factory</code>. Use the factories to determine if a specific <code>Fetcher</code>/<code>Decoder</code> is applicable. Return <code>null</code> if that <code>Fetcher</code>/<code>Decoder</code> is not applicable.</li> </ul>"},{"location":"upgrading_to_coil2/#remove-bitmap-pooling","title":"Remove bitmap pooling","text":"<p>Coil 2.x removes bitmap pooling and its associated classes (<code>BitmapPool</code>, <code>PoolableViewTarget</code>). See here for why it was removed.</p>"},{"location":"upgrading_to_coil3/","title":"Upgrading to Coil 3.x","text":"<p>Coil 3 is the next major version of Coil that has a number of major improvements:</p> <ul> <li>Full support for Compose Multiplatform including all major targets (Android, iOS, JVM, JS, and WASM).</li> <li>Support for multiple networking libraries (Ktor and OkHttp). Alternatively, Coil can be used without a network dependency if you only need to load local/static files.</li> <li>Improved Compose <code>@Preview</code> rendering and support for custom preview behavior via <code>LocalAsyncImagePreviewHandler</code>.</li> <li>Important fixes for bugs that required breaking existing behaviour (outlined below).</li> </ul> <p>This document provides a high-level overview of the main changes from Coil 2 to Coil 3 and highlights any breaking or important changes. It does not cover every binary incompatible change or small behaviour changes.</p> <p>Using Coil 3 in a Compose Multiplatform project? Check out the <code>samples</code> repository for examples.</p>"},{"location":"upgrading_to_coil3/#maven-coordinates-and-package-name","title":"Maven Coordinates and Package Name","text":"<p>Coil's Maven coordinates were updated from <code>io.coil-kt</code> to <code>io.coil-kt.coil3</code> and its package name was updated from <code>coil</code> to <code>coil3</code>. This allows Coil 3 to run side by side with Coil 2 without binary compatibility issues. For example, <code>io.coil-kt:coil:2.7.0</code> is now <code>io.coil-kt.coil3:coil:3.0.0</code>.</p> <p>The <code>coil-base</code> and <code>coil-compose-base</code> artifacts were renamed to <code>coil-core</code> and <code>coil-compose-core</code> respectively to align with the naming conventions used by Coroutines, Ktor, and AndroidX.</p>"},{"location":"upgrading_to_coil3/#network-images","title":"Network Images","text":"<p><code>coil-core</code> no longer supports loading images from the network by default. You must add a dependency on one of Coil's network artifacts. See here for more info.. This was changed so consumers could use different networking libraries or avoid a network dependency if their app doesn't need it.</p> <p>Additionally, cache control headers are no longer respected by default. See here for more info.</p>"},{"location":"upgrading_to_coil3/#multiplatform","title":"Multiplatform","text":"<p>Coil 3 is now a Kotlin Multiplatform library that supports Android, JVM, iOS, macOS, Javascript, and WASM.</p> <p>On Android, Coil uses the standard graphics classes to render images. On non-Android platforms, Coil uses Skiko to render images. Skiko is a set of Kotlin bindings that wrap the Skia graphics engine developed by Google.</p> <p>As part of decoupling from the Android SDK, a number of API changes were made. Notably:</p> <ul> <li><code>Drawable</code> was replaced with a custom <code>Image</code> interface. Use <code>Drawable.asImage()</code> and <code>Image.asDrawable(resources)</code> to convert between the classes on Android. On non-Android platforms use <code>Bitmap.asImage()</code> and <code>Image.toBitmap()</code>.</li> <li>Usages of Android's <code>android.net.Uri</code> class were replaced a multiplatform <code>coil3.Uri</code> class. Any call sites that pass <code>android.net.Uri</code> as <code>ImageRequest.data</code> are unaffected. Custom <code>Fetcher</code>s that rely on receiving an <code>android.net.Uri</code> will need to be updated to use <code>coil3.Uri</code>.</li> <li>Usages of <code>Context</code> were replaced with <code>PlatformContext</code>. <code>PlatformContext</code> is a type alias for <code>Context</code> on Android and can be accessed using <code>PlatformContext.INSTANCE</code> on non-Android platforms. Use <code>LocalPlatformContext.current</code> to get a reference in Compose Multiplatform.</li> <li>The <code>Coil</code> class was renamed to <code>SingletonImageLoader</code>.</li> <li>If you're implementing <code>ImageLoaderFactory</code> in your custom Android <code>Application</code> class, you'll need to switch to implementing <code>SingletonImageLoader.Factory</code> as a replacement for <code>ImageLoaderFactory</code>. Once you implement <code>SingletonImageLoader.Factory</code>, you'll be able to override <code>newImageLoader()</code> if you need or want to override it.</li> </ul> <p>The <code>coil-svg</code> artifact is supported in multiplatform, but the <code>coil-gif</code> and <code>coil-video</code> artifacts continue to be Android-only (for now) as they rely on specific Android decoders and libraries.</p>"},{"location":"upgrading_to_coil3/#compose","title":"Compose","text":"<p>The <code>coil-compose</code> artifact's APIs are mostly unchanged. You can continue using <code>AsyncImage</code>, <code>SubcomposeAsyncImage</code>, and <code>rememberAsyncImagePainter</code> the same way as with Coil 2. Additionally, this methods have been updated to be restartable and skippable which should improve their performance.</p> <ul> <li><code>AsyncImagePainter.state</code> is now a <code>StateFlow</code>. It should be observed using <code>val state = painter.state.collectAsState()</code>.</li> <li><code>AsyncImagePainter</code>'s default <code>SizeResolver</code> no longer waits for the first <code>onDraw</code> call to get the size of the canvas. Instead, <code>AsyncImagePainter</code> defaults to <code>Size.ORIGINAL</code>.</li> <li>The Compose <code>modelEqualityDelegate</code> delegate is now set via a composition local, <code>LocalAsyncImageModelEqualityDelegate</code>, instead of as a parameter to <code>AsyncImage</code>/<code>SubcomposeAsyncImage</code>/<code>rememberAsyncImagePainter</code>.</li> </ul>"},{"location":"upgrading_to_coil3/#general","title":"General","text":"<p>Other important behavior changes include:</p> <ul> <li>First party <code>Fetcher</code>s and <code>Decoder</code>s (e.g. <code>NetworkFetcher.Factory</code>, <code>SvgDecoder</code>, etc.) are now automatically added to each new <code>ImageLoader</code> through a service loader. This behaviour can be disabled with <code>ImageLoader.Builder.serviceLoaderEnabled(false)</code>.</li> <li>Remove support for <code>android.resource://example.package.name/drawable/image</code> URIs as it prevents resource shrinking optimizations. It's recommended to pass <code>R.drawable.image</code> values directly. Passing the resource ID instead of the resource name will still work: <code>android.resource://example.package.name/12345678</code>. If you still needs its functionality you can manually include <code>ResourceUriMapper</code> in your component registry.</li> <li>A file's last write timestamp is no longer added to its cache key by default. This is to avoid reading the disk on the main thread (even for a very short amount of time). This can be re-enabled with <code>ImageRequest.Builder.addLastModifiedToFileCacheKey(true)</code> or <code>ImageLoader.Builder.addLastModifiedToFileCacheKey(true)</code>.</li> <li>Output image dimensions are now enforced to be less than 4096x4096 to guard against accidental OOMs. This can be configured with <code>ImageLoader/ImageRequest.Builder.maxBitmapSize</code>. To disable this behavior set <code>maxBitmapSize</code> to <code>Size.ORIGINAL</code>.</li> <li>Coil 2's <code>Parameters</code> API was replaced by <code>Extras</code>. <code>Extras</code> don't require a string key and instead rely on identity equality. <code>Extras</code> don't support modifying the memory cache key. Instead, use <code>ImageRequest.memoryCacheKeyExtra</code> if your extra affects the memory cache key.</li> <li>Many <code>ImageRequest.Builder</code> functions have moved to be extension functions to more easily support multiplatform.</li> </ul>"},{"location":"videos/","title":"Video Frames","text":"<p>This feature is only available on Android.</p> <p>To add video frame support, import the extension library:</p> <pre><code>implementation(\"io.coil-kt.coil3:coil-video:3.4.0\")\n</code></pre> <p>And add the decoder to your component registry when constructing your <code>ImageLoader</code>:</p> <pre><code>val imageLoader = ImageLoader.Builder(context)\n    .components {\n        add(VideoFrameDecoder.Factory())\n    }\n    .build()\n</code></pre> <p>To specify the time of the frame to extract from a video, use <code>videoFrameMillis</code> or <code>videoFrameMicros</code>:</p> <pre><code>imageView.load(\"/path/to/video.mp4\") {\n    videoFrameMillis(1000)  // extracts the frame at 1 second of the video\n}\n</code></pre> <p>For specifying the exact frame number, use <code>videoFrameIndex</code> (requires API level 28):</p> <pre><code>imageView.load(\"/path/to/video.mp4\") {\n    videoFrameIndex(1234)  // extracts the 1234th frame of the video\n}\n</code></pre> <p>To select a video frame based on a percentage of the video's total duration, use <code>videoFramePercent</code>:</p> <pre><code>imageView.load(\"/path/to/video.mp4\") {\n    videoFramePercent(0.5)  // extracts the frame in the middle of the video's duration\n}\n</code></pre> <p>If no frame position is specified, the first frame of the video will be decoded.</p> <p>The <code>ImageLoader</code> will automatically detect any videos and extract their frames if the request's filename/URI ends with a valid video extension. If it does not, you can set the <code>Decoder</code> explicitly for the request:</p> <pre><code>imageView.load(\"/path/to/video\") {\n    decoderFactory { result, options, _ -&gt; VideoFrameDecoder(result.source, options) }\n}\n</code></pre>"},{"location":"works_with_coil/","title":"Works with Coil","text":"<p>A collection of third party libraries that work nicely with Coil.</p> <ul> <li>Telephoto: Building blocks for designing media experiences in Compose UI.</li> <li>Landscapist: A pluggable, highly optimized Jetpack Compose and Kotlin Multiplatform image loading library that fetches and displays network images with Glide, Coil, and Fresco.</li> </ul> <p>Have a library that works with or builds on top of Coil? Submit a PR to include it here!</p>"}]}